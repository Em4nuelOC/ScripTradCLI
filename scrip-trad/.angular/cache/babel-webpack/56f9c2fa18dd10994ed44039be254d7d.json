{"ast":null,"code":"var _asyncToGenerator = require(\"E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\n/**\n * @license node-stream-zip | (c) 2020 Antelle | https://github.com/antelle/node-stream-zip/blob/master/LICENSE\n * Portions copyright https://github.com/cthackers/adm-zip | https://raw.githubusercontent.com/cthackers/adm-zip/master/LICENSE\n */\nlet fs = require('fs');\n\nconst util = require('util');\n\nconst path = require('path');\n\nconst events = require('events');\n\nconst zlib = require('zlib');\n\nconst stream = require('stream');\n\nconst consts = {\n  /* The local file header */\n  LOCHDR: 30,\n  // LOC header size\n  LOCSIG: 0x04034b50,\n  // \"PK\\003\\004\"\n  LOCVER: 4,\n  // version needed to extract\n  LOCFLG: 6,\n  // general purpose bit flag\n  LOCHOW: 8,\n  // compression method\n  LOCTIM: 10,\n  // modification time (2 bytes time, 2 bytes date)\n  LOCCRC: 14,\n  // uncompressed file crc-32 value\n  LOCSIZ: 18,\n  // compressed size\n  LOCLEN: 22,\n  // uncompressed size\n  LOCNAM: 26,\n  // filename length\n  LOCEXT: 28,\n  // extra field length\n\n  /* The Data descriptor */\n  EXTSIG: 0x08074b50,\n  // \"PK\\007\\008\"\n  EXTHDR: 16,\n  // EXT header size\n  EXTCRC: 4,\n  // uncompressed file crc-32 value\n  EXTSIZ: 8,\n  // compressed size\n  EXTLEN: 12,\n  // uncompressed size\n\n  /* The central directory file header */\n  CENHDR: 46,\n  // CEN header size\n  CENSIG: 0x02014b50,\n  // \"PK\\001\\002\"\n  CENVEM: 4,\n  // version made by\n  CENVER: 6,\n  // version needed to extract\n  CENFLG: 8,\n  // encrypt, decrypt flags\n  CENHOW: 10,\n  // compression method\n  CENTIM: 12,\n  // modification time (2 bytes time, 2 bytes date)\n  CENCRC: 16,\n  // uncompressed file crc-32 value\n  CENSIZ: 20,\n  // compressed size\n  CENLEN: 24,\n  // uncompressed size\n  CENNAM: 28,\n  // filename length\n  CENEXT: 30,\n  // extra field length\n  CENCOM: 32,\n  // file comment length\n  CENDSK: 34,\n  // volume number start\n  CENATT: 36,\n  // internal file attributes\n  CENATX: 38,\n  // external file attributes (host system dependent)\n  CENOFF: 42,\n  // LOC header offset\n\n  /* The entries in the end of central directory */\n  ENDHDR: 22,\n  // END header size\n  ENDSIG: 0x06054b50,\n  // \"PK\\005\\006\"\n  ENDSIGFIRST: 0x50,\n  ENDSUB: 8,\n  // number of entries on this disk\n  ENDTOT: 10,\n  // total number of entries\n  ENDSIZ: 12,\n  // central directory size in bytes\n  ENDOFF: 16,\n  // offset of first CEN header\n  ENDCOM: 20,\n  // zip file comment length\n  MAXFILECOMMENT: 0xffff,\n\n  /* The entries in the end of ZIP64 central directory locator */\n  ENDL64HDR: 20,\n  // ZIP64 end of central directory locator header size\n  ENDL64SIG: 0x07064b50,\n  // ZIP64 end of central directory locator signature\n  ENDL64SIGFIRST: 0x50,\n  ENDL64OFS: 8,\n  // ZIP64 end of central directory offset\n\n  /* The entries in the end of ZIP64 central directory */\n  END64HDR: 56,\n  // ZIP64 end of central directory header size\n  END64SIG: 0x06064b50,\n  // ZIP64 end of central directory signature\n  END64SIGFIRST: 0x50,\n  END64SUB: 24,\n  // number of entries on this disk\n  END64TOT: 32,\n  // total number of entries\n  END64SIZ: 40,\n  END64OFF: 48,\n\n  /* Compression methods */\n  STORED: 0,\n  // no compression\n  SHRUNK: 1,\n  // shrunk\n  REDUCED1: 2,\n  // reduced with compression factor 1\n  REDUCED2: 3,\n  // reduced with compression factor 2\n  REDUCED3: 4,\n  // reduced with compression factor 3\n  REDUCED4: 5,\n  // reduced with compression factor 4\n  IMPLODED: 6,\n  // imploded\n  // 7 reserved\n  DEFLATED: 8,\n  // deflated\n  ENHANCED_DEFLATED: 9,\n  // deflate64\n  PKWARE: 10,\n  // PKWare DCL imploded\n  // 11 reserved\n  BZIP2: 12,\n  //  compressed using BZIP2\n  // 13 reserved\n  LZMA: 14,\n  // LZMA\n  // 15-17 reserved\n  IBM_TERSE: 18,\n  // compressed using IBM TERSE\n  IBM_LZ77: 19,\n  //IBM LZ77 z\n\n  /* General purpose bit flag */\n  FLG_ENC: 0,\n  // encrypted file\n  FLG_COMP1: 1,\n  // compression option\n  FLG_COMP2: 2,\n  // compression option\n  FLG_DESC: 4,\n  // data descriptor\n  FLG_ENH: 8,\n  // enhanced deflation\n  FLG_STR: 16,\n  // strong encryption\n  FLG_LNG: 1024,\n  // language encoding\n  FLG_MSK: 4096,\n  // mask header values\n  FLG_ENTRY_ENC: 1,\n\n  /* 4.5 Extensible data fields */\n  EF_ID: 0,\n  EF_SIZE: 2,\n\n  /* Header IDs */\n  ID_ZIP64: 0x0001,\n  ID_AVINFO: 0x0007,\n  ID_PFS: 0x0008,\n  ID_OS2: 0x0009,\n  ID_NTFS: 0x000a,\n  ID_OPENVMS: 0x000c,\n  ID_UNIX: 0x000d,\n  ID_FORK: 0x000e,\n  ID_PATCH: 0x000f,\n  ID_X509_PKCS7: 0x0014,\n  ID_X509_CERTID_F: 0x0015,\n  ID_X509_CERTID_C: 0x0016,\n  ID_STRONGENC: 0x0017,\n  ID_RECORD_MGT: 0x0018,\n  ID_X509_PKCS7_RL: 0x0019,\n  ID_IBM1: 0x0065,\n  ID_IBM2: 0x0066,\n  ID_POSZIP: 0x4690,\n  EF_ZIP64_OR_32: 0xffffffff,\n  EF_ZIP64_OR_16: 0xffff\n};\n\nconst StreamZip = function (config) {\n  let fd, fileSize, chunkSize, op, centralDirectory, closed;\n  const ready = false,\n        that = this,\n        entries = config.storeEntries !== false ? {} : null,\n        fileName = config.file,\n        textDecoder = config.nameEncoding ? new TextDecoder(config.nameEncoding) : null;\n  open();\n\n  function open() {\n    if (config.fd) {\n      fd = config.fd;\n      readFile();\n    } else {\n      fs.open(fileName, 'r', (err, f) => {\n        if (err) {\n          return that.emit('error', err);\n        }\n\n        fd = f;\n        readFile();\n      });\n    }\n  }\n\n  function readFile() {\n    fs.fstat(fd, (err, stat) => {\n      if (err) {\n        return that.emit('error', err);\n      }\n\n      fileSize = stat.size;\n      chunkSize = config.chunkSize || Math.round(fileSize / 1000);\n      chunkSize = Math.max(Math.min(chunkSize, Math.min(128 * 1024, fileSize)), Math.min(1024, fileSize));\n      readCentralDirectory();\n    });\n  }\n\n  function readUntilFoundCallback(err, bytesRead) {\n    if (err || !bytesRead) {\n      return that.emit('error', err || new Error('Archive read error'));\n    }\n\n    let pos = op.lastPos;\n    let bufferPosition = pos - op.win.position;\n    const buffer = op.win.buffer;\n    const minPos = op.minPos;\n\n    while (--pos >= minPos && --bufferPosition >= 0) {\n      if (buffer.length - bufferPosition >= 4 && buffer[bufferPosition] === op.firstByte) {\n        // quick check first signature byte\n        if (buffer.readUInt32LE(bufferPosition) === op.sig) {\n          op.lastBufferPosition = bufferPosition;\n          op.lastBytesRead = bytesRead;\n          op.complete();\n          return;\n        }\n      }\n    }\n\n    if (pos === minPos) {\n      return that.emit('error', new Error('Bad archive'));\n    }\n\n    op.lastPos = pos + 1;\n    op.chunkSize *= 2;\n\n    if (pos <= minPos) {\n      return that.emit('error', new Error('Bad archive'));\n    }\n\n    const expandLength = Math.min(op.chunkSize, pos - minPos);\n    op.win.expandLeft(expandLength, readUntilFoundCallback);\n  }\n\n  function readCentralDirectory() {\n    const totalReadLength = Math.min(consts.ENDHDR + consts.MAXFILECOMMENT, fileSize);\n    op = {\n      win: new FileWindowBuffer(fd),\n      totalReadLength,\n      minPos: fileSize - totalReadLength,\n      lastPos: fileSize,\n      chunkSize: Math.min(1024, chunkSize),\n      firstByte: consts.ENDSIGFIRST,\n      sig: consts.ENDSIG,\n      complete: readCentralDirectoryComplete\n    };\n    op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n  }\n\n  function readCentralDirectoryComplete() {\n    const buffer = op.win.buffer;\n    const pos = op.lastBufferPosition;\n\n    try {\n      centralDirectory = new CentralDirectoryHeader();\n      centralDirectory.read(buffer.slice(pos, pos + consts.ENDHDR));\n      centralDirectory.headerOffset = op.win.position + pos;\n\n      if (centralDirectory.commentLength) {\n        that.comment = buffer.slice(pos + consts.ENDHDR, pos + consts.ENDHDR + centralDirectory.commentLength).toString();\n      } else {\n        that.comment = null;\n      }\n\n      that.entriesCount = centralDirectory.volumeEntries;\n      that.centralDirectory = centralDirectory;\n\n      if (centralDirectory.volumeEntries === consts.EF_ZIP64_OR_16 && centralDirectory.totalEntries === consts.EF_ZIP64_OR_16 || centralDirectory.size === consts.EF_ZIP64_OR_32 || centralDirectory.offset === consts.EF_ZIP64_OR_32) {\n        readZip64CentralDirectoryLocator();\n      } else {\n        op = {};\n        readEntries();\n      }\n    } catch (err) {\n      that.emit('error', err);\n    }\n  }\n\n  function readZip64CentralDirectoryLocator() {\n    const length = consts.ENDL64HDR;\n\n    if (op.lastBufferPosition > length) {\n      op.lastBufferPosition -= length;\n      readZip64CentralDirectoryLocatorComplete();\n    } else {\n      op = {\n        win: op.win,\n        totalReadLength: length,\n        minPos: op.win.position - length,\n        lastPos: op.win.position,\n        chunkSize: op.chunkSize,\n        firstByte: consts.ENDL64SIGFIRST,\n        sig: consts.ENDL64SIG,\n        complete: readZip64CentralDirectoryLocatorComplete\n      };\n      op.win.read(op.lastPos - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n  }\n\n  function readZip64CentralDirectoryLocatorComplete() {\n    const buffer = op.win.buffer;\n    const locHeader = new CentralDirectoryLoc64Header();\n    locHeader.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.ENDL64HDR));\n    const readLength = fileSize - locHeader.headerOffset;\n    op = {\n      win: op.win,\n      totalReadLength: readLength,\n      minPos: locHeader.headerOffset,\n      lastPos: op.lastPos,\n      chunkSize: op.chunkSize,\n      firstByte: consts.END64SIGFIRST,\n      sig: consts.END64SIG,\n      complete: readZip64CentralDirectoryComplete\n    };\n    op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n  }\n\n  function readZip64CentralDirectoryComplete() {\n    const buffer = op.win.buffer;\n    const zip64cd = new CentralDirectoryZip64Header();\n    zip64cd.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.END64HDR));\n    that.centralDirectory.volumeEntries = zip64cd.volumeEntries;\n    that.centralDirectory.totalEntries = zip64cd.totalEntries;\n    that.centralDirectory.size = zip64cd.size;\n    that.centralDirectory.offset = zip64cd.offset;\n    that.entriesCount = zip64cd.volumeEntries;\n    op = {};\n    readEntries();\n  }\n\n  function readEntries() {\n    op = {\n      win: new FileWindowBuffer(fd),\n      pos: centralDirectory.offset,\n      chunkSize,\n      entriesLeft: centralDirectory.volumeEntries\n    };\n    op.win.read(op.pos, Math.min(chunkSize, fileSize - op.pos), readEntriesCallback);\n  }\n\n  function readEntriesCallback(err, bytesRead) {\n    if (err || !bytesRead) {\n      return that.emit('error', err || new Error('Entries read error'));\n    }\n\n    let bufferPos = op.pos - op.win.position;\n    let entry = op.entry;\n    const buffer = op.win.buffer;\n    const bufferLength = buffer.length;\n\n    try {\n      while (op.entriesLeft > 0) {\n        if (!entry) {\n          entry = new ZipEntry();\n          entry.readHeader(buffer, bufferPos);\n          entry.headerOffset = op.win.position + bufferPos;\n          op.entry = entry;\n          op.pos += consts.CENHDR;\n          bufferPos += consts.CENHDR;\n        }\n\n        const entryHeaderSize = entry.fnameLen + entry.extraLen + entry.comLen;\n        const advanceBytes = entryHeaderSize + (op.entriesLeft > 1 ? consts.CENHDR : 0);\n\n        if (bufferLength - bufferPos < advanceBytes) {\n          op.win.moveRight(chunkSize, readEntriesCallback, bufferPos);\n          op.move = true;\n          return;\n        }\n\n        entry.read(buffer, bufferPos, textDecoder);\n\n        if (!config.skipEntryNameValidation) {\n          entry.validateName();\n        }\n\n        if (entries) {\n          entries[entry.name] = entry;\n        }\n\n        that.emit('entry', entry);\n        op.entry = entry = null;\n        op.entriesLeft--;\n        op.pos += entryHeaderSize;\n        bufferPos += entryHeaderSize;\n      }\n\n      that.emit('ready');\n    } catch (err) {\n      that.emit('error', err);\n    }\n  }\n\n  function checkEntriesExist() {\n    if (!entries) {\n      throw new Error('storeEntries disabled');\n    }\n  }\n\n  Object.defineProperty(this, 'ready', {\n    get() {\n      return ready;\n    }\n\n  });\n\n  this.entry = function (name) {\n    checkEntriesExist();\n    return entries[name];\n  };\n\n  this.entries = function () {\n    checkEntriesExist();\n    return entries;\n  };\n\n  this.stream = function (entry, callback) {\n    return this.openEntry(entry, (err, entry) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const offset = dataOffset(entry);\n      let entryStream = new EntryDataReaderStream(fd, offset, entry.compressedSize);\n\n      if (entry.method === consts.STORED) {// nothing to do\n      } else if (entry.method === consts.DEFLATED) {\n        entryStream = entryStream.pipe(zlib.createInflateRaw());\n      } else {\n        return callback(new Error('Unknown compression method: ' + entry.method));\n      }\n\n      if (canVerifyCrc(entry)) {\n        entryStream = entryStream.pipe(new EntryVerifyStream(entryStream, entry.crc, entry.size));\n      }\n\n      callback(null, entryStream);\n    }, false);\n  };\n\n  this.entryDataSync = function (entry) {\n    let err = null;\n    this.openEntry(entry, (e, en) => {\n      err = e;\n      entry = en;\n    }, true);\n\n    if (err) {\n      throw err;\n    }\n\n    let data = Buffer.alloc(entry.compressedSize);\n    new FsRead(fd, data, 0, entry.compressedSize, dataOffset(entry), e => {\n      err = e;\n    }).read(true);\n\n    if (err) {\n      throw err;\n    }\n\n    if (entry.method === consts.STORED) {// nothing to do\n    } else if (entry.method === consts.DEFLATED || entry.method === consts.ENHANCED_DEFLATED) {\n      data = zlib.inflateRawSync(data);\n    } else {\n      throw new Error('Unknown compression method: ' + entry.method);\n    }\n\n    if (data.length !== entry.size) {\n      throw new Error('Invalid size');\n    }\n\n    if (canVerifyCrc(entry)) {\n      const verify = new CrcVerify(entry.crc, entry.size);\n      verify.data(data);\n    }\n\n    return data;\n  };\n\n  this.openEntry = function (entry, callback, sync) {\n    if (typeof entry === 'string') {\n      checkEntriesExist();\n      entry = entries[entry];\n\n      if (!entry) {\n        return callback(new Error('Entry not found'));\n      }\n    }\n\n    if (!entry.isFile) {\n      return callback(new Error('Entry is not file'));\n    }\n\n    if (!fd) {\n      return callback(new Error('Archive closed'));\n    }\n\n    const buffer = Buffer.alloc(consts.LOCHDR);\n    new FsRead(fd, buffer, 0, buffer.length, entry.offset, err => {\n      if (err) {\n        return callback(err);\n      }\n\n      let readEx;\n\n      try {\n        entry.readDataHeader(buffer);\n\n        if (entry.encrypted) {\n          readEx = new Error('Entry encrypted');\n        }\n      } catch (ex) {\n        readEx = ex;\n      }\n\n      callback(readEx, entry);\n    }).read(sync);\n  };\n\n  function dataOffset(entry) {\n    return entry.offset + consts.LOCHDR + entry.fnameLen + entry.extraLen;\n  }\n\n  function canVerifyCrc(entry) {\n    // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n    return (entry.flags & 0x8) !== 0x8;\n  }\n\n  function extract(entry, outPath, callback) {\n    that.stream(entry, (err, stm) => {\n      if (err) {\n        callback(err);\n      } else {\n        let fsStm, errThrown;\n        stm.on('error', err => {\n          errThrown = err;\n\n          if (fsStm) {\n            stm.unpipe(fsStm);\n            fsStm.close(() => {\n              callback(err);\n            });\n          }\n        });\n        fs.open(outPath, 'w', (err, fdFile) => {\n          if (err) {\n            return callback(err);\n          }\n\n          if (errThrown) {\n            fs.close(fd, () => {\n              callback(errThrown);\n            });\n            return;\n          }\n\n          fsStm = fs.createWriteStream(outPath, {\n            fd: fdFile\n          });\n          fsStm.on('finish', () => {\n            that.emit('extract', entry, outPath);\n\n            if (!errThrown) {\n              callback();\n            }\n          });\n          stm.pipe(fsStm);\n        });\n      }\n    });\n  }\n\n  function createDirectories(baseDir, dirs, callback) {\n    if (!dirs.length) {\n      return callback();\n    }\n\n    let dir = dirs.shift();\n    dir = path.join(baseDir, path.join(...dir));\n    fs.mkdir(dir, {\n      recursive: true\n    }, err => {\n      if (err && err.code !== 'EEXIST') {\n        return callback(err);\n      }\n\n      createDirectories(baseDir, dirs, callback);\n    });\n  }\n\n  function extractFiles(baseDir, baseRelPath, files, callback, extractedCount) {\n    if (!files.length) {\n      return callback(null, extractedCount);\n    }\n\n    const file = files.shift();\n    const targetPath = path.join(baseDir, file.name.replace(baseRelPath, ''));\n    extract(file, targetPath, err => {\n      if (err) {\n        return callback(err, extractedCount);\n      }\n\n      extractFiles(baseDir, baseRelPath, files, callback, extractedCount + 1);\n    });\n  }\n\n  this.extract = function (entry, outPath, callback) {\n    let entryName = entry || '';\n\n    if (typeof entry === 'string') {\n      entry = this.entry(entry);\n\n      if (entry) {\n        entryName = entry.name;\n      } else {\n        if (entryName.length && entryName[entryName.length - 1] !== '/') {\n          entryName += '/';\n        }\n      }\n    }\n\n    if (!entry || entry.isDirectory) {\n      const files = [],\n            dirs = [],\n            allDirs = {};\n\n      for (const e in entries) {\n        if (Object.prototype.hasOwnProperty.call(entries, e) && e.lastIndexOf(entryName, 0) === 0) {\n          let relPath = e.replace(entryName, '');\n          const childEntry = entries[e];\n\n          if (childEntry.isFile) {\n            files.push(childEntry);\n            relPath = path.dirname(relPath);\n          }\n\n          if (relPath && !allDirs[relPath] && relPath !== '.') {\n            allDirs[relPath] = true;\n            let parts = relPath.split('/').filter(f => {\n              return f;\n            });\n\n            if (parts.length) {\n              dirs.push(parts);\n            }\n\n            while (parts.length > 1) {\n              parts = parts.slice(0, parts.length - 1);\n              const partsPath = parts.join('/');\n\n              if (allDirs[partsPath] || partsPath === '.') {\n                break;\n              }\n\n              allDirs[partsPath] = true;\n              dirs.push(parts);\n            }\n          }\n        }\n      }\n\n      dirs.sort((x, y) => {\n        return x.length - y.length;\n      });\n\n      if (dirs.length) {\n        createDirectories(outPath, dirs, err => {\n          if (err) {\n            callback(err);\n          } else {\n            extractFiles(outPath, entryName, files, callback, 0);\n          }\n        });\n      } else {\n        extractFiles(outPath, entryName, files, callback, 0);\n      }\n    } else {\n      fs.stat(outPath, (err, stat) => {\n        if (stat && stat.isDirectory()) {\n          extract(entry, path.join(outPath, path.basename(entry.name)), callback);\n        } else {\n          extract(entry, outPath, callback);\n        }\n      });\n    }\n  };\n\n  this.close = function (callback) {\n    if (closed || !fd) {\n      closed = true;\n\n      if (callback) {\n        callback();\n      }\n    } else {\n      closed = true;\n      fs.close(fd, err => {\n        fd = null;\n\n        if (callback) {\n          callback(err);\n        }\n      });\n    }\n  };\n\n  const originalEmit = events.EventEmitter.prototype.emit;\n\n  this.emit = function (...args) {\n    if (!closed) {\n      return originalEmit.call(this, ...args);\n    }\n  };\n};\n\nStreamZip.setFs = function (customFs) {\n  fs = customFs;\n};\n\nStreamZip.debugLog = (...args) => {\n  if (StreamZip.debug) {\n    // eslint-disable-next-line no-console\n    console.log(...args);\n  }\n};\n\nutil.inherits(StreamZip, events.EventEmitter);\nconst propZip = Symbol('zip');\nStreamZip.async = class StreamZipAsync extends events.EventEmitter {\n  constructor(config) {\n    super();\n    const zip = new StreamZip(config);\n    zip.on('entry', entry => this.emit('entry', entry));\n    zip.on('extract', (entry, outPath) => this.emit('extract', entry, outPath));\n    this[propZip] = new Promise((resolve, reject) => {\n      zip.on('ready', () => {\n        zip.removeListener('error', reject);\n        resolve(zip);\n      });\n      zip.on('error', reject);\n    });\n  }\n\n  get entriesCount() {\n    return this[propZip].then(zip => zip.entriesCount);\n  }\n\n  get comment() {\n    return this[propZip].then(zip => zip.comment);\n  }\n\n  entry(name) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const zip = yield _this[propZip];\n      return zip.entry(name);\n    })();\n  }\n\n  entries() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const zip = yield _this2[propZip];\n      return zip.entries();\n    })();\n  }\n\n  stream(entry) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const zip = yield _this3[propZip];\n      return new Promise((resolve, reject) => {\n        zip.stream(entry, (err, stm) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(stm);\n          }\n        });\n      });\n    })();\n  }\n\n  entryData(entry) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const stm = yield _this4.stream(entry);\n      return new Promise((resolve, reject) => {\n        const data = [];\n        stm.on('data', chunk => data.push(chunk));\n        stm.on('end', () => {\n          resolve(Buffer.concat(data));\n        });\n        stm.on('error', err => {\n          stm.removeAllListeners('end');\n          reject(err);\n        });\n      });\n    })();\n  }\n\n  extract(entry, outPath) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const zip = yield _this5[propZip];\n      return new Promise((resolve, reject) => {\n        zip.extract(entry, outPath, (err, res) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(res);\n          }\n        });\n      });\n    })();\n  }\n\n  close() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const zip = yield _this6[propZip];\n      return new Promise((resolve, reject) => {\n        zip.close(err => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    })();\n  }\n\n};\n\nclass CentralDirectoryHeader {\n  read(data) {\n    if (data.length !== consts.ENDHDR || data.readUInt32LE(0) !== consts.ENDSIG) {\n      throw new Error('Invalid central directory');\n    } // number of entries on this volume\n\n\n    this.volumeEntries = data.readUInt16LE(consts.ENDSUB); // total number of entries\n\n    this.totalEntries = data.readUInt16LE(consts.ENDTOT); // central directory size in bytes\n\n    this.size = data.readUInt32LE(consts.ENDSIZ); // offset of first CEN header\n\n    this.offset = data.readUInt32LE(consts.ENDOFF); // zip file comment length\n\n    this.commentLength = data.readUInt16LE(consts.ENDCOM);\n  }\n\n}\n\nclass CentralDirectoryLoc64Header {\n  read(data) {\n    if (data.length !== consts.ENDL64HDR || data.readUInt32LE(0) !== consts.ENDL64SIG) {\n      throw new Error('Invalid zip64 central directory locator');\n    } // ZIP64 EOCD header offset\n\n\n    this.headerOffset = readUInt64LE(data, consts.ENDSUB);\n  }\n\n}\n\nclass CentralDirectoryZip64Header {\n  read(data) {\n    if (data.length !== consts.END64HDR || data.readUInt32LE(0) !== consts.END64SIG) {\n      throw new Error('Invalid central directory');\n    } // number of entries on this volume\n\n\n    this.volumeEntries = readUInt64LE(data, consts.END64SUB); // total number of entries\n\n    this.totalEntries = readUInt64LE(data, consts.END64TOT); // central directory size in bytes\n\n    this.size = readUInt64LE(data, consts.END64SIZ); // offset of first CEN header\n\n    this.offset = readUInt64LE(data, consts.END64OFF);\n  }\n\n}\n\nclass ZipEntry {\n  readHeader(data, offset) {\n    // data should be 46 bytes and start with \"PK 01 02\"\n    if (data.length < offset + consts.CENHDR || data.readUInt32LE(offset) !== consts.CENSIG) {\n      throw new Error('Invalid entry header');\n    } // version made by\n\n\n    this.verMade = data.readUInt16LE(offset + consts.CENVEM); // version needed to extract\n\n    this.version = data.readUInt16LE(offset + consts.CENVER); // encrypt, decrypt flags\n\n    this.flags = data.readUInt16LE(offset + consts.CENFLG); // compression method\n\n    this.method = data.readUInt16LE(offset + consts.CENHOW); // modification time (2 bytes time, 2 bytes date)\n\n    const timebytes = data.readUInt16LE(offset + consts.CENTIM);\n    const datebytes = data.readUInt16LE(offset + consts.CENTIM + 2);\n    this.time = parseZipTime(timebytes, datebytes); // uncompressed file crc-32 value\n\n    this.crc = data.readUInt32LE(offset + consts.CENCRC); // compressed size\n\n    this.compressedSize = data.readUInt32LE(offset + consts.CENSIZ); // uncompressed size\n\n    this.size = data.readUInt32LE(offset + consts.CENLEN); // filename length\n\n    this.fnameLen = data.readUInt16LE(offset + consts.CENNAM); // extra field length\n\n    this.extraLen = data.readUInt16LE(offset + consts.CENEXT); // file comment length\n\n    this.comLen = data.readUInt16LE(offset + consts.CENCOM); // volume number start\n\n    this.diskStart = data.readUInt16LE(offset + consts.CENDSK); // internal file attributes\n\n    this.inattr = data.readUInt16LE(offset + consts.CENATT); // external file attributes\n\n    this.attr = data.readUInt32LE(offset + consts.CENATX); // LOC header offset\n\n    this.offset = data.readUInt32LE(offset + consts.CENOFF);\n  }\n\n  readDataHeader(data) {\n    // 30 bytes and should start with \"PK\\003\\004\"\n    if (data.readUInt32LE(0) !== consts.LOCSIG) {\n      throw new Error('Invalid local header');\n    } // version needed to extract\n\n\n    this.version = data.readUInt16LE(consts.LOCVER); // general purpose bit flag\n\n    this.flags = data.readUInt16LE(consts.LOCFLG); // compression method\n\n    this.method = data.readUInt16LE(consts.LOCHOW); // modification time (2 bytes time ; 2 bytes date)\n\n    const timebytes = data.readUInt16LE(consts.LOCTIM);\n    const datebytes = data.readUInt16LE(consts.LOCTIM + 2);\n    this.time = parseZipTime(timebytes, datebytes); // uncompressed file crc-32 value\n\n    this.crc = data.readUInt32LE(consts.LOCCRC) || this.crc; // compressed size\n\n    const compressedSize = data.readUInt32LE(consts.LOCSIZ);\n\n    if (compressedSize && compressedSize !== consts.EF_ZIP64_OR_32) {\n      this.compressedSize = compressedSize;\n    } // uncompressed size\n\n\n    const size = data.readUInt32LE(consts.LOCLEN);\n\n    if (size && size !== consts.EF_ZIP64_OR_32) {\n      this.size = size;\n    } // filename length\n\n\n    this.fnameLen = data.readUInt16LE(consts.LOCNAM); // extra field length\n\n    this.extraLen = data.readUInt16LE(consts.LOCEXT);\n  }\n\n  read(data, offset, textDecoder) {\n    const nameData = data.slice(offset, offset += this.fnameLen);\n    this.name = textDecoder ? textDecoder.decode(new Uint8Array(nameData)) : nameData.toString('utf8');\n    const lastChar = data[offset - 1];\n    this.isDirectory = lastChar === 47 || lastChar === 92;\n\n    if (this.extraLen) {\n      this.readExtra(data, offset);\n      offset += this.extraLen;\n    }\n\n    this.comment = this.comLen ? data.slice(offset, offset + this.comLen).toString() : null;\n  }\n\n  validateName() {\n    if (/\\\\|^\\w+:|^\\/|(^|\\/)\\.\\.(\\/|$)/.test(this.name)) {\n      throw new Error('Malicious entry: ' + this.name);\n    }\n  }\n\n  readExtra(data, offset) {\n    let signature, size;\n    const maxPos = offset + this.extraLen;\n\n    while (offset < maxPos) {\n      signature = data.readUInt16LE(offset);\n      offset += 2;\n      size = data.readUInt16LE(offset);\n      offset += 2;\n\n      if (consts.ID_ZIP64 === signature) {\n        this.parseZip64Extra(data, offset, size);\n      }\n\n      offset += size;\n    }\n  }\n\n  parseZip64Extra(data, offset, length) {\n    if (length >= 8 && this.size === consts.EF_ZIP64_OR_32) {\n      this.size = readUInt64LE(data, offset);\n      offset += 8;\n      length -= 8;\n    }\n\n    if (length >= 8 && this.compressedSize === consts.EF_ZIP64_OR_32) {\n      this.compressedSize = readUInt64LE(data, offset);\n      offset += 8;\n      length -= 8;\n    }\n\n    if (length >= 8 && this.offset === consts.EF_ZIP64_OR_32) {\n      this.offset = readUInt64LE(data, offset);\n      offset += 8;\n      length -= 8;\n    }\n\n    if (length >= 4 && this.diskStart === consts.EF_ZIP64_OR_16) {\n      this.diskStart = data.readUInt32LE(offset); // offset += 4; length -= 4;\n    }\n  }\n\n  get encrypted() {\n    return (this.flags & consts.FLG_ENTRY_ENC) === consts.FLG_ENTRY_ENC;\n  }\n\n  get isFile() {\n    return !this.isDirectory;\n  }\n\n}\n\nclass FsRead {\n  constructor(fd, buffer, offset, length, position, callback) {\n    this.fd = fd;\n    this.buffer = buffer;\n    this.offset = offset;\n    this.length = length;\n    this.position = position;\n    this.callback = callback;\n    this.bytesRead = 0;\n    this.waiting = false;\n  }\n\n  read(sync) {\n    StreamZip.debugLog('read', this.position, this.bytesRead, this.length, this.offset);\n    this.waiting = true;\n    let err;\n\n    if (sync) {\n      let bytesRead = 0;\n\n      try {\n        bytesRead = fs.readSync(this.fd, this.buffer, this.offset + this.bytesRead, this.length - this.bytesRead, this.position + this.bytesRead);\n      } catch (e) {\n        err = e;\n      }\n\n      this.readCallback(sync, err, err ? bytesRead : null);\n    } else {\n      fs.read(this.fd, this.buffer, this.offset + this.bytesRead, this.length - this.bytesRead, this.position + this.bytesRead, this.readCallback.bind(this, sync));\n    }\n  }\n\n  readCallback(sync, err, bytesRead) {\n    if (typeof bytesRead === 'number') {\n      this.bytesRead += bytesRead;\n    }\n\n    if (err || !bytesRead || this.bytesRead === this.length) {\n      this.waiting = false;\n      return this.callback(err, this.bytesRead);\n    } else {\n      this.read(sync);\n    }\n  }\n\n}\n\nclass FileWindowBuffer {\n  constructor(fd) {\n    this.position = 0;\n    this.buffer = Buffer.alloc(0);\n    this.fd = fd;\n    this.fsOp = null;\n  }\n\n  checkOp() {\n    if (this.fsOp && this.fsOp.waiting) {\n      throw new Error('Operation in progress');\n    }\n  }\n\n  read(pos, length, callback) {\n    this.checkOp();\n\n    if (this.buffer.length < length) {\n      this.buffer = Buffer.alloc(length);\n    }\n\n    this.position = pos;\n    this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n  }\n\n  expandLeft(length, callback) {\n    this.checkOp();\n    this.buffer = Buffer.concat([Buffer.alloc(length), this.buffer]);\n    this.position -= length;\n\n    if (this.position < 0) {\n      this.position = 0;\n    }\n\n    this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n  }\n\n  expandRight(length, callback) {\n    this.checkOp();\n    const offset = this.buffer.length;\n    this.buffer = Buffer.concat([this.buffer, Buffer.alloc(length)]);\n    this.fsOp = new FsRead(this.fd, this.buffer, offset, length, this.position + offset, callback).read();\n  }\n\n  moveRight(length, callback, shift) {\n    this.checkOp();\n\n    if (shift) {\n      this.buffer.copy(this.buffer, 0, shift);\n    } else {\n      shift = 0;\n    }\n\n    this.position += shift;\n    this.fsOp = new FsRead(this.fd, this.buffer, this.buffer.length - shift, shift, this.position + this.buffer.length - shift, callback).read();\n  }\n\n}\n\nclass EntryDataReaderStream extends stream.Readable {\n  constructor(fd, offset, length) {\n    super();\n    this.fd = fd;\n    this.offset = offset;\n    this.length = length;\n    this.pos = 0;\n    this.readCallback = this.readCallback.bind(this);\n  }\n\n  _read(n) {\n    const buffer = Buffer.alloc(Math.min(n, this.length - this.pos));\n\n    if (buffer.length) {\n      fs.read(this.fd, buffer, 0, buffer.length, this.offset + this.pos, this.readCallback);\n    } else {\n      this.push(null);\n    }\n  }\n\n  readCallback(err, bytesRead, buffer) {\n    this.pos += bytesRead;\n\n    if (err) {\n      this.emit('error', err);\n      this.push(null);\n    } else if (!bytesRead) {\n      this.push(null);\n    } else {\n      if (bytesRead !== buffer.length) {\n        buffer = buffer.slice(0, bytesRead);\n      }\n\n      this.push(buffer);\n    }\n  }\n\n}\n\nclass EntryVerifyStream extends stream.Transform {\n  constructor(baseStm, crc, size) {\n    super();\n    this.verify = new CrcVerify(crc, size);\n    baseStm.on('error', e => {\n      this.emit('error', e);\n    });\n  }\n\n  _transform(data, encoding, callback) {\n    let err;\n\n    try {\n      this.verify.data(data);\n    } catch (e) {\n      err = e;\n    }\n\n    callback(err, data);\n  }\n\n}\n\nclass CrcVerify {\n  constructor(crc, size) {\n    this.crc = crc;\n    this.size = size;\n    this.state = {\n      crc: ~0,\n      size: 0\n    };\n  }\n\n  data(data) {\n    const crcTable = CrcVerify.getCrcTable();\n    let crc = this.state.crc;\n    let off = 0;\n    let len = data.length;\n\n    while (--len >= 0) {\n      crc = crcTable[(crc ^ data[off++]) & 0xff] ^ crc >>> 8;\n    }\n\n    this.state.crc = crc;\n    this.state.size += data.length;\n\n    if (this.state.size >= this.size) {\n      const buf = Buffer.alloc(4);\n      buf.writeInt32LE(~this.state.crc & 0xffffffff, 0);\n      crc = buf.readUInt32LE(0);\n\n      if (crc !== this.crc) {\n        throw new Error('Invalid CRC');\n      }\n\n      if (this.state.size !== this.size) {\n        throw new Error('Invalid size');\n      }\n    }\n  }\n\n  static getCrcTable() {\n    let crcTable = CrcVerify.crcTable;\n\n    if (!crcTable) {\n      CrcVerify.crcTable = crcTable = [];\n      const b = Buffer.alloc(4);\n\n      for (let n = 0; n < 256; n++) {\n        let c = n;\n\n        for (let k = 8; --k >= 0;) {\n          if ((c & 1) !== 0) {\n            c = 0xedb88320 ^ c >>> 1;\n          } else {\n            c = c >>> 1;\n          }\n        }\n\n        if (c < 0) {\n          b.writeInt32LE(c, 0);\n          c = b.readUInt32LE(0);\n        }\n\n        crcTable[n] = c;\n      }\n    }\n\n    return crcTable;\n  }\n\n}\n\nfunction parseZipTime(timebytes, datebytes) {\n  const timebits = toBits(timebytes, 16);\n  const datebits = toBits(datebytes, 16);\n  const mt = {\n    h: parseInt(timebits.slice(0, 5).join(''), 2),\n    m: parseInt(timebits.slice(5, 11).join(''), 2),\n    s: parseInt(timebits.slice(11, 16).join(''), 2) * 2,\n    Y: parseInt(datebits.slice(0, 7).join(''), 2) + 1980,\n    M: parseInt(datebits.slice(7, 11).join(''), 2),\n    D: parseInt(datebits.slice(11, 16).join(''), 2)\n  };\n  const dt_str = [mt.Y, mt.M, mt.D].join('-') + ' ' + [mt.h, mt.m, mt.s].join(':') + ' GMT+0';\n  return new Date(dt_str).getTime();\n}\n\nfunction toBits(dec, size) {\n  let b = (dec >>> 0).toString(2);\n\n  while (b.length < size) {\n    b = '0' + b;\n  }\n\n  return b.split('');\n}\n\nfunction readUInt64LE(buffer, offset) {\n  return buffer.readUInt32LE(offset + 4) * 0x0000000100000000 + buffer.readUInt32LE(offset);\n}\n\nmodule.exports = StreamZip;","map":{"version":3,"sources":["E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/node-stream-zip/node_stream_zip.js"],"names":["fs","require","util","path","events","zlib","stream","consts","LOCHDR","LOCSIG","LOCVER","LOCFLG","LOCHOW","LOCTIM","LOCCRC","LOCSIZ","LOCLEN","LOCNAM","LOCEXT","EXTSIG","EXTHDR","EXTCRC","EXTSIZ","EXTLEN","CENHDR","CENSIG","CENVEM","CENVER","CENFLG","CENHOW","CENTIM","CENCRC","CENSIZ","CENLEN","CENNAM","CENEXT","CENCOM","CENDSK","CENATT","CENATX","CENOFF","ENDHDR","ENDSIG","ENDSIGFIRST","ENDSUB","ENDTOT","ENDSIZ","ENDOFF","ENDCOM","MAXFILECOMMENT","ENDL64HDR","ENDL64SIG","ENDL64SIGFIRST","ENDL64OFS","END64HDR","END64SIG","END64SIGFIRST","END64SUB","END64TOT","END64SIZ","END64OFF","STORED","SHRUNK","REDUCED1","REDUCED2","REDUCED3","REDUCED4","IMPLODED","DEFLATED","ENHANCED_DEFLATED","PKWARE","BZIP2","LZMA","IBM_TERSE","IBM_LZ77","FLG_ENC","FLG_COMP1","FLG_COMP2","FLG_DESC","FLG_ENH","FLG_STR","FLG_LNG","FLG_MSK","FLG_ENTRY_ENC","EF_ID","EF_SIZE","ID_ZIP64","ID_AVINFO","ID_PFS","ID_OS2","ID_NTFS","ID_OPENVMS","ID_UNIX","ID_FORK","ID_PATCH","ID_X509_PKCS7","ID_X509_CERTID_F","ID_X509_CERTID_C","ID_STRONGENC","ID_RECORD_MGT","ID_X509_PKCS7_RL","ID_IBM1","ID_IBM2","ID_POSZIP","EF_ZIP64_OR_32","EF_ZIP64_OR_16","StreamZip","config","fd","fileSize","chunkSize","op","centralDirectory","closed","ready","that","entries","storeEntries","fileName","file","textDecoder","nameEncoding","TextDecoder","open","readFile","err","f","emit","fstat","stat","size","Math","round","max","min","readCentralDirectory","readUntilFoundCallback","bytesRead","Error","pos","lastPos","bufferPosition","win","position","buffer","minPos","length","firstByte","readUInt32LE","sig","lastBufferPosition","lastBytesRead","complete","expandLength","expandLeft","totalReadLength","FileWindowBuffer","readCentralDirectoryComplete","read","CentralDirectoryHeader","slice","headerOffset","commentLength","comment","toString","entriesCount","volumeEntries","totalEntries","offset","readZip64CentralDirectoryLocator","readEntries","readZip64CentralDirectoryLocatorComplete","locHeader","CentralDirectoryLoc64Header","readLength","readZip64CentralDirectoryComplete","zip64cd","CentralDirectoryZip64Header","entriesLeft","readEntriesCallback","bufferPos","entry","bufferLength","ZipEntry","readHeader","entryHeaderSize","fnameLen","extraLen","comLen","advanceBytes","moveRight","move","skipEntryNameValidation","validateName","name","checkEntriesExist","Object","defineProperty","get","callback","openEntry","dataOffset","entryStream","EntryDataReaderStream","compressedSize","method","pipe","createInflateRaw","canVerifyCrc","EntryVerifyStream","crc","entryDataSync","e","en","data","Buffer","alloc","FsRead","inflateRawSync","verify","CrcVerify","sync","isFile","readEx","readDataHeader","encrypted","ex","flags","extract","outPath","stm","fsStm","errThrown","on","unpipe","close","fdFile","createWriteStream","createDirectories","baseDir","dirs","dir","shift","join","mkdir","recursive","code","extractFiles","baseRelPath","files","extractedCount","targetPath","replace","entryName","isDirectory","allDirs","prototype","hasOwnProperty","call","lastIndexOf","relPath","childEntry","push","dirname","parts","split","filter","partsPath","sort","x","y","basename","originalEmit","EventEmitter","args","setFs","customFs","debugLog","debug","console","log","inherits","propZip","Symbol","async","StreamZipAsync","constructor","zip","Promise","resolve","reject","removeListener","then","entryData","chunk","concat","removeAllListeners","res","readUInt16LE","readUInt64LE","verMade","version","timebytes","datebytes","time","parseZipTime","diskStart","inattr","attr","nameData","decode","Uint8Array","lastChar","readExtra","test","signature","maxPos","parseZip64Extra","waiting","readSync","readCallback","bind","fsOp","checkOp","expandRight","copy","Readable","_read","n","Transform","baseStm","_transform","encoding","state","crcTable","getCrcTable","off","len","buf","writeInt32LE","b","c","k","timebits","toBits","datebits","mt","h","parseInt","m","s","Y","M","D","dt_str","Date","getTime","dec","module","exports"],"mappings":"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","sourcesContent":["/**\n * @license node-stream-zip | (c) 2020 Antelle | https://github.com/antelle/node-stream-zip/blob/master/LICENSE\n * Portions copyright https://github.com/cthackers/adm-zip | https://raw.githubusercontent.com/cthackers/adm-zip/master/LICENSE\n */\n\nlet fs = require('fs');\nconst util = require('util');\nconst path = require('path');\nconst events = require('events');\nconst zlib = require('zlib');\nconst stream = require('stream');\n\nconst consts = {\n    /* The local file header */\n    LOCHDR: 30, // LOC header size\n    LOCSIG: 0x04034b50, // \"PK\\003\\004\"\n    LOCVER: 4, // version needed to extract\n    LOCFLG: 6, // general purpose bit flag\n    LOCHOW: 8, // compression method\n    LOCTIM: 10, // modification time (2 bytes time, 2 bytes date)\n    LOCCRC: 14, // uncompressed file crc-32 value\n    LOCSIZ: 18, // compressed size\n    LOCLEN: 22, // uncompressed size\n    LOCNAM: 26, // filename length\n    LOCEXT: 28, // extra field length\n\n    /* The Data descriptor */\n    EXTSIG: 0x08074b50, // \"PK\\007\\008\"\n    EXTHDR: 16, // EXT header size\n    EXTCRC: 4, // uncompressed file crc-32 value\n    EXTSIZ: 8, // compressed size\n    EXTLEN: 12, // uncompressed size\n\n    /* The central directory file header */\n    CENHDR: 46, // CEN header size\n    CENSIG: 0x02014b50, // \"PK\\001\\002\"\n    CENVEM: 4, // version made by\n    CENVER: 6, // version needed to extract\n    CENFLG: 8, // encrypt, decrypt flags\n    CENHOW: 10, // compression method\n    CENTIM: 12, // modification time (2 bytes time, 2 bytes date)\n    CENCRC: 16, // uncompressed file crc-32 value\n    CENSIZ: 20, // compressed size\n    CENLEN: 24, // uncompressed size\n    CENNAM: 28, // filename length\n    CENEXT: 30, // extra field length\n    CENCOM: 32, // file comment length\n    CENDSK: 34, // volume number start\n    CENATT: 36, // internal file attributes\n    CENATX: 38, // external file attributes (host system dependent)\n    CENOFF: 42, // LOC header offset\n\n    /* The entries in the end of central directory */\n    ENDHDR: 22, // END header size\n    ENDSIG: 0x06054b50, // \"PK\\005\\006\"\n    ENDSIGFIRST: 0x50,\n    ENDSUB: 8, // number of entries on this disk\n    ENDTOT: 10, // total number of entries\n    ENDSIZ: 12, // central directory size in bytes\n    ENDOFF: 16, // offset of first CEN header\n    ENDCOM: 20, // zip file comment length\n    MAXFILECOMMENT: 0xffff,\n\n    /* The entries in the end of ZIP64 central directory locator */\n    ENDL64HDR: 20, // ZIP64 end of central directory locator header size\n    ENDL64SIG: 0x07064b50, // ZIP64 end of central directory locator signature\n    ENDL64SIGFIRST: 0x50,\n    ENDL64OFS: 8, // ZIP64 end of central directory offset\n\n    /* The entries in the end of ZIP64 central directory */\n    END64HDR: 56, // ZIP64 end of central directory header size\n    END64SIG: 0x06064b50, // ZIP64 end of central directory signature\n    END64SIGFIRST: 0x50,\n    END64SUB: 24, // number of entries on this disk\n    END64TOT: 32, // total number of entries\n    END64SIZ: 40,\n    END64OFF: 48,\n\n    /* Compression methods */\n    STORED: 0, // no compression\n    SHRUNK: 1, // shrunk\n    REDUCED1: 2, // reduced with compression factor 1\n    REDUCED2: 3, // reduced with compression factor 2\n    REDUCED3: 4, // reduced with compression factor 3\n    REDUCED4: 5, // reduced with compression factor 4\n    IMPLODED: 6, // imploded\n    // 7 reserved\n    DEFLATED: 8, // deflated\n    ENHANCED_DEFLATED: 9, // deflate64\n    PKWARE: 10, // PKWare DCL imploded\n    // 11 reserved\n    BZIP2: 12, //  compressed using BZIP2\n    // 13 reserved\n    LZMA: 14, // LZMA\n    // 15-17 reserved\n    IBM_TERSE: 18, // compressed using IBM TERSE\n    IBM_LZ77: 19, //IBM LZ77 z\n\n    /* General purpose bit flag */\n    FLG_ENC: 0, // encrypted file\n    FLG_COMP1: 1, // compression option\n    FLG_COMP2: 2, // compression option\n    FLG_DESC: 4, // data descriptor\n    FLG_ENH: 8, // enhanced deflation\n    FLG_STR: 16, // strong encryption\n    FLG_LNG: 1024, // language encoding\n    FLG_MSK: 4096, // mask header values\n    FLG_ENTRY_ENC: 1,\n\n    /* 4.5 Extensible data fields */\n    EF_ID: 0,\n    EF_SIZE: 2,\n\n    /* Header IDs */\n    ID_ZIP64: 0x0001,\n    ID_AVINFO: 0x0007,\n    ID_PFS: 0x0008,\n    ID_OS2: 0x0009,\n    ID_NTFS: 0x000a,\n    ID_OPENVMS: 0x000c,\n    ID_UNIX: 0x000d,\n    ID_FORK: 0x000e,\n    ID_PATCH: 0x000f,\n    ID_X509_PKCS7: 0x0014,\n    ID_X509_CERTID_F: 0x0015,\n    ID_X509_CERTID_C: 0x0016,\n    ID_STRONGENC: 0x0017,\n    ID_RECORD_MGT: 0x0018,\n    ID_X509_PKCS7_RL: 0x0019,\n    ID_IBM1: 0x0065,\n    ID_IBM2: 0x0066,\n    ID_POSZIP: 0x4690,\n\n    EF_ZIP64_OR_32: 0xffffffff,\n    EF_ZIP64_OR_16: 0xffff,\n};\n\nconst StreamZip = function (config) {\n    let fd, fileSize, chunkSize, op, centralDirectory, closed;\n    const ready = false,\n        that = this,\n        entries = config.storeEntries !== false ? {} : null,\n        fileName = config.file,\n        textDecoder = config.nameEncoding ? new TextDecoder(config.nameEncoding) : null;\n\n    open();\n\n    function open() {\n        if (config.fd) {\n            fd = config.fd;\n            readFile();\n        } else {\n            fs.open(fileName, 'r', (err, f) => {\n                if (err) {\n                    return that.emit('error', err);\n                }\n                fd = f;\n                readFile();\n            });\n        }\n    }\n\n    function readFile() {\n        fs.fstat(fd, (err, stat) => {\n            if (err) {\n                return that.emit('error', err);\n            }\n            fileSize = stat.size;\n            chunkSize = config.chunkSize || Math.round(fileSize / 1000);\n            chunkSize = Math.max(\n                Math.min(chunkSize, Math.min(128 * 1024, fileSize)),\n                Math.min(1024, fileSize)\n            );\n            readCentralDirectory();\n        });\n    }\n\n    function readUntilFoundCallback(err, bytesRead) {\n        if (err || !bytesRead) {\n            return that.emit('error', err || new Error('Archive read error'));\n        }\n        let pos = op.lastPos;\n        let bufferPosition = pos - op.win.position;\n        const buffer = op.win.buffer;\n        const minPos = op.minPos;\n        while (--pos >= minPos && --bufferPosition >= 0) {\n            if (buffer.length - bufferPosition >= 4 && buffer[bufferPosition] === op.firstByte) {\n                // quick check first signature byte\n                if (buffer.readUInt32LE(bufferPosition) === op.sig) {\n                    op.lastBufferPosition = bufferPosition;\n                    op.lastBytesRead = bytesRead;\n                    op.complete();\n                    return;\n                }\n            }\n        }\n        if (pos === minPos) {\n            return that.emit('error', new Error('Bad archive'));\n        }\n        op.lastPos = pos + 1;\n        op.chunkSize *= 2;\n        if (pos <= minPos) {\n            return that.emit('error', new Error('Bad archive'));\n        }\n        const expandLength = Math.min(op.chunkSize, pos - minPos);\n        op.win.expandLeft(expandLength, readUntilFoundCallback);\n    }\n\n    function readCentralDirectory() {\n        const totalReadLength = Math.min(consts.ENDHDR + consts.MAXFILECOMMENT, fileSize);\n        op = {\n            win: new FileWindowBuffer(fd),\n            totalReadLength,\n            minPos: fileSize - totalReadLength,\n            lastPos: fileSize,\n            chunkSize: Math.min(1024, chunkSize),\n            firstByte: consts.ENDSIGFIRST,\n            sig: consts.ENDSIG,\n            complete: readCentralDirectoryComplete,\n        };\n        op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n\n    function readCentralDirectoryComplete() {\n        const buffer = op.win.buffer;\n        const pos = op.lastBufferPosition;\n        try {\n            centralDirectory = new CentralDirectoryHeader();\n            centralDirectory.read(buffer.slice(pos, pos + consts.ENDHDR));\n            centralDirectory.headerOffset = op.win.position + pos;\n            if (centralDirectory.commentLength) {\n                that.comment = buffer\n                    .slice(\n                        pos + consts.ENDHDR,\n                        pos + consts.ENDHDR + centralDirectory.commentLength\n                    )\n                    .toString();\n            } else {\n                that.comment = null;\n            }\n            that.entriesCount = centralDirectory.volumeEntries;\n            that.centralDirectory = centralDirectory;\n            if (\n                (centralDirectory.volumeEntries === consts.EF_ZIP64_OR_16 &&\n                    centralDirectory.totalEntries === consts.EF_ZIP64_OR_16) ||\n                centralDirectory.size === consts.EF_ZIP64_OR_32 ||\n                centralDirectory.offset === consts.EF_ZIP64_OR_32\n            ) {\n                readZip64CentralDirectoryLocator();\n            } else {\n                op = {};\n                readEntries();\n            }\n        } catch (err) {\n            that.emit('error', err);\n        }\n    }\n\n    function readZip64CentralDirectoryLocator() {\n        const length = consts.ENDL64HDR;\n        if (op.lastBufferPosition > length) {\n            op.lastBufferPosition -= length;\n            readZip64CentralDirectoryLocatorComplete();\n        } else {\n            op = {\n                win: op.win,\n                totalReadLength: length,\n                minPos: op.win.position - length,\n                lastPos: op.win.position,\n                chunkSize: op.chunkSize,\n                firstByte: consts.ENDL64SIGFIRST,\n                sig: consts.ENDL64SIG,\n                complete: readZip64CentralDirectoryLocatorComplete,\n            };\n            op.win.read(op.lastPos - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n        }\n    }\n\n    function readZip64CentralDirectoryLocatorComplete() {\n        const buffer = op.win.buffer;\n        const locHeader = new CentralDirectoryLoc64Header();\n        locHeader.read(\n            buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.ENDL64HDR)\n        );\n        const readLength = fileSize - locHeader.headerOffset;\n        op = {\n            win: op.win,\n            totalReadLength: readLength,\n            minPos: locHeader.headerOffset,\n            lastPos: op.lastPos,\n            chunkSize: op.chunkSize,\n            firstByte: consts.END64SIGFIRST,\n            sig: consts.END64SIG,\n            complete: readZip64CentralDirectoryComplete,\n        };\n        op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n\n    function readZip64CentralDirectoryComplete() {\n        const buffer = op.win.buffer;\n        const zip64cd = new CentralDirectoryZip64Header();\n        zip64cd.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.END64HDR));\n        that.centralDirectory.volumeEntries = zip64cd.volumeEntries;\n        that.centralDirectory.totalEntries = zip64cd.totalEntries;\n        that.centralDirectory.size = zip64cd.size;\n        that.centralDirectory.offset = zip64cd.offset;\n        that.entriesCount = zip64cd.volumeEntries;\n        op = {};\n        readEntries();\n    }\n\n    function readEntries() {\n        op = {\n            win: new FileWindowBuffer(fd),\n            pos: centralDirectory.offset,\n            chunkSize,\n            entriesLeft: centralDirectory.volumeEntries,\n        };\n        op.win.read(op.pos, Math.min(chunkSize, fileSize - op.pos), readEntriesCallback);\n    }\n\n    function readEntriesCallback(err, bytesRead) {\n        if (err || !bytesRead) {\n            return that.emit('error', err || new Error('Entries read error'));\n        }\n        let bufferPos = op.pos - op.win.position;\n        let entry = op.entry;\n        const buffer = op.win.buffer;\n        const bufferLength = buffer.length;\n        try {\n            while (op.entriesLeft > 0) {\n                if (!entry) {\n                    entry = new ZipEntry();\n                    entry.readHeader(buffer, bufferPos);\n                    entry.headerOffset = op.win.position + bufferPos;\n                    op.entry = entry;\n                    op.pos += consts.CENHDR;\n                    bufferPos += consts.CENHDR;\n                }\n                const entryHeaderSize = entry.fnameLen + entry.extraLen + entry.comLen;\n                const advanceBytes = entryHeaderSize + (op.entriesLeft > 1 ? consts.CENHDR : 0);\n                if (bufferLength - bufferPos < advanceBytes) {\n                    op.win.moveRight(chunkSize, readEntriesCallback, bufferPos);\n                    op.move = true;\n                    return;\n                }\n                entry.read(buffer, bufferPos, textDecoder);\n                if (!config.skipEntryNameValidation) {\n                    entry.validateName();\n                }\n                if (entries) {\n                    entries[entry.name] = entry;\n                }\n                that.emit('entry', entry);\n                op.entry = entry = null;\n                op.entriesLeft--;\n                op.pos += entryHeaderSize;\n                bufferPos += entryHeaderSize;\n            }\n            that.emit('ready');\n        } catch (err) {\n            that.emit('error', err);\n        }\n    }\n\n    function checkEntriesExist() {\n        if (!entries) {\n            throw new Error('storeEntries disabled');\n        }\n    }\n\n    Object.defineProperty(this, 'ready', {\n        get() {\n            return ready;\n        },\n    });\n\n    this.entry = function (name) {\n        checkEntriesExist();\n        return entries[name];\n    };\n\n    this.entries = function () {\n        checkEntriesExist();\n        return entries;\n    };\n\n    this.stream = function (entry, callback) {\n        return this.openEntry(\n            entry,\n            (err, entry) => {\n                if (err) {\n                    return callback(err);\n                }\n                const offset = dataOffset(entry);\n                let entryStream = new EntryDataReaderStream(fd, offset, entry.compressedSize);\n                if (entry.method === consts.STORED) {\n                    // nothing to do\n                } else if (entry.method === consts.DEFLATED) {\n                    entryStream = entryStream.pipe(zlib.createInflateRaw());\n                } else {\n                    return callback(new Error('Unknown compression method: ' + entry.method));\n                }\n                if (canVerifyCrc(entry)) {\n                    entryStream = entryStream.pipe(\n                        new EntryVerifyStream(entryStream, entry.crc, entry.size)\n                    );\n                }\n                callback(null, entryStream);\n            },\n            false\n        );\n    };\n\n    this.entryDataSync = function (entry) {\n        let err = null;\n        this.openEntry(\n            entry,\n            (e, en) => {\n                err = e;\n                entry = en;\n            },\n            true\n        );\n        if (err) {\n            throw err;\n        }\n        let data = Buffer.alloc(entry.compressedSize);\n        new FsRead(fd, data, 0, entry.compressedSize, dataOffset(entry), (e) => {\n            err = e;\n        }).read(true);\n        if (err) {\n            throw err;\n        }\n        if (entry.method === consts.STORED) {\n            // nothing to do\n        } else if (entry.method === consts.DEFLATED || entry.method === consts.ENHANCED_DEFLATED) {\n            data = zlib.inflateRawSync(data);\n        } else {\n            throw new Error('Unknown compression method: ' + entry.method);\n        }\n        if (data.length !== entry.size) {\n            throw new Error('Invalid size');\n        }\n        if (canVerifyCrc(entry)) {\n            const verify = new CrcVerify(entry.crc, entry.size);\n            verify.data(data);\n        }\n        return data;\n    };\n\n    this.openEntry = function (entry, callback, sync) {\n        if (typeof entry === 'string') {\n            checkEntriesExist();\n            entry = entries[entry];\n            if (!entry) {\n                return callback(new Error('Entry not found'));\n            }\n        }\n        if (!entry.isFile) {\n            return callback(new Error('Entry is not file'));\n        }\n        if (!fd) {\n            return callback(new Error('Archive closed'));\n        }\n        const buffer = Buffer.alloc(consts.LOCHDR);\n        new FsRead(fd, buffer, 0, buffer.length, entry.offset, (err) => {\n            if (err) {\n                return callback(err);\n            }\n            let readEx;\n            try {\n                entry.readDataHeader(buffer);\n                if (entry.encrypted) {\n                    readEx = new Error('Entry encrypted');\n                }\n            } catch (ex) {\n                readEx = ex;\n            }\n            callback(readEx, entry);\n        }).read(sync);\n    };\n\n    function dataOffset(entry) {\n        return entry.offset + consts.LOCHDR + entry.fnameLen + entry.extraLen;\n    }\n\n    function canVerifyCrc(entry) {\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n        return (entry.flags & 0x8) !== 0x8;\n    }\n\n    function extract(entry, outPath, callback) {\n        that.stream(entry, (err, stm) => {\n            if (err) {\n                callback(err);\n            } else {\n                let fsStm, errThrown;\n                stm.on('error', (err) => {\n                    errThrown = err;\n                    if (fsStm) {\n                        stm.unpipe(fsStm);\n                        fsStm.close(() => {\n                            callback(err);\n                        });\n                    }\n                });\n                fs.open(outPath, 'w', (err, fdFile) => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    if (errThrown) {\n                        fs.close(fd, () => {\n                            callback(errThrown);\n                        });\n                        return;\n                    }\n                    fsStm = fs.createWriteStream(outPath, { fd: fdFile });\n                    fsStm.on('finish', () => {\n                        that.emit('extract', entry, outPath);\n                        if (!errThrown) {\n                            callback();\n                        }\n                    });\n                    stm.pipe(fsStm);\n                });\n            }\n        });\n    }\n\n    function createDirectories(baseDir, dirs, callback) {\n        if (!dirs.length) {\n            return callback();\n        }\n        let dir = dirs.shift();\n        dir = path.join(baseDir, path.join(...dir));\n        fs.mkdir(dir, { recursive: true }, (err) => {\n            if (err && err.code !== 'EEXIST') {\n                return callback(err);\n            }\n            createDirectories(baseDir, dirs, callback);\n        });\n    }\n\n    function extractFiles(baseDir, baseRelPath, files, callback, extractedCount) {\n        if (!files.length) {\n            return callback(null, extractedCount);\n        }\n        const file = files.shift();\n        const targetPath = path.join(baseDir, file.name.replace(baseRelPath, ''));\n        extract(file, targetPath, (err) => {\n            if (err) {\n                return callback(err, extractedCount);\n            }\n            extractFiles(baseDir, baseRelPath, files, callback, extractedCount + 1);\n        });\n    }\n\n    this.extract = function (entry, outPath, callback) {\n        let entryName = entry || '';\n        if (typeof entry === 'string') {\n            entry = this.entry(entry);\n            if (entry) {\n                entryName = entry.name;\n            } else {\n                if (entryName.length && entryName[entryName.length - 1] !== '/') {\n                    entryName += '/';\n                }\n            }\n        }\n        if (!entry || entry.isDirectory) {\n            const files = [],\n                dirs = [],\n                allDirs = {};\n            for (const e in entries) {\n                if (\n                    Object.prototype.hasOwnProperty.call(entries, e) &&\n                    e.lastIndexOf(entryName, 0) === 0\n                ) {\n                    let relPath = e.replace(entryName, '');\n                    const childEntry = entries[e];\n                    if (childEntry.isFile) {\n                        files.push(childEntry);\n                        relPath = path.dirname(relPath);\n                    }\n                    if (relPath && !allDirs[relPath] && relPath !== '.') {\n                        allDirs[relPath] = true;\n                        let parts = relPath.split('/').filter((f) => {\n                            return f;\n                        });\n                        if (parts.length) {\n                            dirs.push(parts);\n                        }\n                        while (parts.length > 1) {\n                            parts = parts.slice(0, parts.length - 1);\n                            const partsPath = parts.join('/');\n                            if (allDirs[partsPath] || partsPath === '.') {\n                                break;\n                            }\n                            allDirs[partsPath] = true;\n                            dirs.push(parts);\n                        }\n                    }\n                }\n            }\n            dirs.sort((x, y) => {\n                return x.length - y.length;\n            });\n            if (dirs.length) {\n                createDirectories(outPath, dirs, (err) => {\n                    if (err) {\n                        callback(err);\n                    } else {\n                        extractFiles(outPath, entryName, files, callback, 0);\n                    }\n                });\n            } else {\n                extractFiles(outPath, entryName, files, callback, 0);\n            }\n        } else {\n            fs.stat(outPath, (err, stat) => {\n                if (stat && stat.isDirectory()) {\n                    extract(entry, path.join(outPath, path.basename(entry.name)), callback);\n                } else {\n                    extract(entry, outPath, callback);\n                }\n            });\n        }\n    };\n\n    this.close = function (callback) {\n        if (closed || !fd) {\n            closed = true;\n            if (callback) {\n                callback();\n            }\n        } else {\n            closed = true;\n            fs.close(fd, (err) => {\n                fd = null;\n                if (callback) {\n                    callback(err);\n                }\n            });\n        }\n    };\n\n    const originalEmit = events.EventEmitter.prototype.emit;\n    this.emit = function (...args) {\n        if (!closed) {\n            return originalEmit.call(this, ...args);\n        }\n    };\n};\n\nStreamZip.setFs = function (customFs) {\n    fs = customFs;\n};\n\nStreamZip.debugLog = (...args) => {\n    if (StreamZip.debug) {\n        // eslint-disable-next-line no-console\n        console.log(...args);\n    }\n};\n\nutil.inherits(StreamZip, events.EventEmitter);\n\nconst propZip = Symbol('zip');\n\nStreamZip.async = class StreamZipAsync extends events.EventEmitter {\n    constructor(config) {\n        super();\n\n        const zip = new StreamZip(config);\n\n        zip.on('entry', (entry) => this.emit('entry', entry));\n        zip.on('extract', (entry, outPath) => this.emit('extract', entry, outPath));\n\n        this[propZip] = new Promise((resolve, reject) => {\n            zip.on('ready', () => {\n                zip.removeListener('error', reject);\n                resolve(zip);\n            });\n            zip.on('error', reject);\n        });\n    }\n\n    get entriesCount() {\n        return this[propZip].then((zip) => zip.entriesCount);\n    }\n\n    get comment() {\n        return this[propZip].then((zip) => zip.comment);\n    }\n\n    async entry(name) {\n        const zip = await this[propZip];\n        return zip.entry(name);\n    }\n\n    async entries() {\n        const zip = await this[propZip];\n        return zip.entries();\n    }\n\n    async stream(entry) {\n        const zip = await this[propZip];\n        return new Promise((resolve, reject) => {\n            zip.stream(entry, (err, stm) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(stm);\n                }\n            });\n        });\n    }\n\n    async entryData(entry) {\n        const stm = await this.stream(entry);\n        return new Promise((resolve, reject) => {\n            const data = [];\n            stm.on('data', (chunk) => data.push(chunk));\n            stm.on('end', () => {\n                resolve(Buffer.concat(data));\n            });\n            stm.on('error', (err) => {\n                stm.removeAllListeners('end');\n                reject(err);\n            });\n        });\n    }\n\n    async extract(entry, outPath) {\n        const zip = await this[propZip];\n        return new Promise((resolve, reject) => {\n            zip.extract(entry, outPath, (err, res) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res);\n                }\n            });\n        });\n    }\n\n    async close() {\n        const zip = await this[propZip];\n        return new Promise((resolve, reject) => {\n            zip.close((err) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n};\n\nclass CentralDirectoryHeader {\n    read(data) {\n        if (data.length !== consts.ENDHDR || data.readUInt32LE(0) !== consts.ENDSIG) {\n            throw new Error('Invalid central directory');\n        }\n        // number of entries on this volume\n        this.volumeEntries = data.readUInt16LE(consts.ENDSUB);\n        // total number of entries\n        this.totalEntries = data.readUInt16LE(consts.ENDTOT);\n        // central directory size in bytes\n        this.size = data.readUInt32LE(consts.ENDSIZ);\n        // offset of first CEN header\n        this.offset = data.readUInt32LE(consts.ENDOFF);\n        // zip file comment length\n        this.commentLength = data.readUInt16LE(consts.ENDCOM);\n    }\n}\n\nclass CentralDirectoryLoc64Header {\n    read(data) {\n        if (data.length !== consts.ENDL64HDR || data.readUInt32LE(0) !== consts.ENDL64SIG) {\n            throw new Error('Invalid zip64 central directory locator');\n        }\n        // ZIP64 EOCD header offset\n        this.headerOffset = readUInt64LE(data, consts.ENDSUB);\n    }\n}\n\nclass CentralDirectoryZip64Header {\n    read(data) {\n        if (data.length !== consts.END64HDR || data.readUInt32LE(0) !== consts.END64SIG) {\n            throw new Error('Invalid central directory');\n        }\n        // number of entries on this volume\n        this.volumeEntries = readUInt64LE(data, consts.END64SUB);\n        // total number of entries\n        this.totalEntries = readUInt64LE(data, consts.END64TOT);\n        // central directory size in bytes\n        this.size = readUInt64LE(data, consts.END64SIZ);\n        // offset of first CEN header\n        this.offset = readUInt64LE(data, consts.END64OFF);\n    }\n}\n\nclass ZipEntry {\n    readHeader(data, offset) {\n        // data should be 46 bytes and start with \"PK 01 02\"\n        if (data.length < offset + consts.CENHDR || data.readUInt32LE(offset) !== consts.CENSIG) {\n            throw new Error('Invalid entry header');\n        }\n        // version made by\n        this.verMade = data.readUInt16LE(offset + consts.CENVEM);\n        // version needed to extract\n        this.version = data.readUInt16LE(offset + consts.CENVER);\n        // encrypt, decrypt flags\n        this.flags = data.readUInt16LE(offset + consts.CENFLG);\n        // compression method\n        this.method = data.readUInt16LE(offset + consts.CENHOW);\n        // modification time (2 bytes time, 2 bytes date)\n        const timebytes = data.readUInt16LE(offset + consts.CENTIM);\n        const datebytes = data.readUInt16LE(offset + consts.CENTIM + 2);\n        this.time = parseZipTime(timebytes, datebytes);\n\n        // uncompressed file crc-32 value\n        this.crc = data.readUInt32LE(offset + consts.CENCRC);\n        // compressed size\n        this.compressedSize = data.readUInt32LE(offset + consts.CENSIZ);\n        // uncompressed size\n        this.size = data.readUInt32LE(offset + consts.CENLEN);\n        // filename length\n        this.fnameLen = data.readUInt16LE(offset + consts.CENNAM);\n        // extra field length\n        this.extraLen = data.readUInt16LE(offset + consts.CENEXT);\n        // file comment length\n        this.comLen = data.readUInt16LE(offset + consts.CENCOM);\n        // volume number start\n        this.diskStart = data.readUInt16LE(offset + consts.CENDSK);\n        // internal file attributes\n        this.inattr = data.readUInt16LE(offset + consts.CENATT);\n        // external file attributes\n        this.attr = data.readUInt32LE(offset + consts.CENATX);\n        // LOC header offset\n        this.offset = data.readUInt32LE(offset + consts.CENOFF);\n    }\n\n    readDataHeader(data) {\n        // 30 bytes and should start with \"PK\\003\\004\"\n        if (data.readUInt32LE(0) !== consts.LOCSIG) {\n            throw new Error('Invalid local header');\n        }\n        // version needed to extract\n        this.version = data.readUInt16LE(consts.LOCVER);\n        // general purpose bit flag\n        this.flags = data.readUInt16LE(consts.LOCFLG);\n        // compression method\n        this.method = data.readUInt16LE(consts.LOCHOW);\n        // modification time (2 bytes time ; 2 bytes date)\n        const timebytes = data.readUInt16LE(consts.LOCTIM);\n        const datebytes = data.readUInt16LE(consts.LOCTIM + 2);\n        this.time = parseZipTime(timebytes, datebytes);\n\n        // uncompressed file crc-32 value\n        this.crc = data.readUInt32LE(consts.LOCCRC) || this.crc;\n        // compressed size\n        const compressedSize = data.readUInt32LE(consts.LOCSIZ);\n        if (compressedSize && compressedSize !== consts.EF_ZIP64_OR_32) {\n            this.compressedSize = compressedSize;\n        }\n        // uncompressed size\n        const size = data.readUInt32LE(consts.LOCLEN);\n        if (size && size !== consts.EF_ZIP64_OR_32) {\n            this.size = size;\n        }\n        // filename length\n        this.fnameLen = data.readUInt16LE(consts.LOCNAM);\n        // extra field length\n        this.extraLen = data.readUInt16LE(consts.LOCEXT);\n    }\n\n    read(data, offset, textDecoder) {\n        const nameData = data.slice(offset, (offset += this.fnameLen));\n        this.name = textDecoder\n            ? textDecoder.decode(new Uint8Array(nameData))\n            : nameData.toString('utf8');\n        const lastChar = data[offset - 1];\n        this.isDirectory = lastChar === 47 || lastChar === 92;\n\n        if (this.extraLen) {\n            this.readExtra(data, offset);\n            offset += this.extraLen;\n        }\n        this.comment = this.comLen ? data.slice(offset, offset + this.comLen).toString() : null;\n    }\n\n    validateName() {\n        if (/\\\\|^\\w+:|^\\/|(^|\\/)\\.\\.(\\/|$)/.test(this.name)) {\n            throw new Error('Malicious entry: ' + this.name);\n        }\n    }\n\n    readExtra(data, offset) {\n        let signature, size;\n        const maxPos = offset + this.extraLen;\n        while (offset < maxPos) {\n            signature = data.readUInt16LE(offset);\n            offset += 2;\n            size = data.readUInt16LE(offset);\n            offset += 2;\n            if (consts.ID_ZIP64 === signature) {\n                this.parseZip64Extra(data, offset, size);\n            }\n            offset += size;\n        }\n    }\n\n    parseZip64Extra(data, offset, length) {\n        if (length >= 8 && this.size === consts.EF_ZIP64_OR_32) {\n            this.size = readUInt64LE(data, offset);\n            offset += 8;\n            length -= 8;\n        }\n        if (length >= 8 && this.compressedSize === consts.EF_ZIP64_OR_32) {\n            this.compressedSize = readUInt64LE(data, offset);\n            offset += 8;\n            length -= 8;\n        }\n        if (length >= 8 && this.offset === consts.EF_ZIP64_OR_32) {\n            this.offset = readUInt64LE(data, offset);\n            offset += 8;\n            length -= 8;\n        }\n        if (length >= 4 && this.diskStart === consts.EF_ZIP64_OR_16) {\n            this.diskStart = data.readUInt32LE(offset);\n            // offset += 4; length -= 4;\n        }\n    }\n\n    get encrypted() {\n        return (this.flags & consts.FLG_ENTRY_ENC) === consts.FLG_ENTRY_ENC;\n    }\n\n    get isFile() {\n        return !this.isDirectory;\n    }\n}\n\nclass FsRead {\n    constructor(fd, buffer, offset, length, position, callback) {\n        this.fd = fd;\n        this.buffer = buffer;\n        this.offset = offset;\n        this.length = length;\n        this.position = position;\n        this.callback = callback;\n        this.bytesRead = 0;\n        this.waiting = false;\n    }\n\n    read(sync) {\n        StreamZip.debugLog('read', this.position, this.bytesRead, this.length, this.offset);\n        this.waiting = true;\n        let err;\n        if (sync) {\n            let bytesRead = 0;\n            try {\n                bytesRead = fs.readSync(\n                    this.fd,\n                    this.buffer,\n                    this.offset + this.bytesRead,\n                    this.length - this.bytesRead,\n                    this.position + this.bytesRead\n                );\n            } catch (e) {\n                err = e;\n            }\n            this.readCallback(sync, err, err ? bytesRead : null);\n        } else {\n            fs.read(\n                this.fd,\n                this.buffer,\n                this.offset + this.bytesRead,\n                this.length - this.bytesRead,\n                this.position + this.bytesRead,\n                this.readCallback.bind(this, sync)\n            );\n        }\n    }\n\n    readCallback(sync, err, bytesRead) {\n        if (typeof bytesRead === 'number') {\n            this.bytesRead += bytesRead;\n        }\n        if (err || !bytesRead || this.bytesRead === this.length) {\n            this.waiting = false;\n            return this.callback(err, this.bytesRead);\n        } else {\n            this.read(sync);\n        }\n    }\n}\n\nclass FileWindowBuffer {\n    constructor(fd) {\n        this.position = 0;\n        this.buffer = Buffer.alloc(0);\n        this.fd = fd;\n        this.fsOp = null;\n    }\n\n    checkOp() {\n        if (this.fsOp && this.fsOp.waiting) {\n            throw new Error('Operation in progress');\n        }\n    }\n\n    read(pos, length, callback) {\n        this.checkOp();\n        if (this.buffer.length < length) {\n            this.buffer = Buffer.alloc(length);\n        }\n        this.position = pos;\n        this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n    }\n\n    expandLeft(length, callback) {\n        this.checkOp();\n        this.buffer = Buffer.concat([Buffer.alloc(length), this.buffer]);\n        this.position -= length;\n        if (this.position < 0) {\n            this.position = 0;\n        }\n        this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n    }\n\n    expandRight(length, callback) {\n        this.checkOp();\n        const offset = this.buffer.length;\n        this.buffer = Buffer.concat([this.buffer, Buffer.alloc(length)]);\n        this.fsOp = new FsRead(\n            this.fd,\n            this.buffer,\n            offset,\n            length,\n            this.position + offset,\n            callback\n        ).read();\n    }\n\n    moveRight(length, callback, shift) {\n        this.checkOp();\n        if (shift) {\n            this.buffer.copy(this.buffer, 0, shift);\n        } else {\n            shift = 0;\n        }\n        this.position += shift;\n        this.fsOp = new FsRead(\n            this.fd,\n            this.buffer,\n            this.buffer.length - shift,\n            shift,\n            this.position + this.buffer.length - shift,\n            callback\n        ).read();\n    }\n}\n\nclass EntryDataReaderStream extends stream.Readable {\n    constructor(fd, offset, length) {\n        super();\n        this.fd = fd;\n        this.offset = offset;\n        this.length = length;\n        this.pos = 0;\n        this.readCallback = this.readCallback.bind(this);\n    }\n\n    _read(n) {\n        const buffer = Buffer.alloc(Math.min(n, this.length - this.pos));\n        if (buffer.length) {\n            fs.read(this.fd, buffer, 0, buffer.length, this.offset + this.pos, this.readCallback);\n        } else {\n            this.push(null);\n        }\n    }\n\n    readCallback(err, bytesRead, buffer) {\n        this.pos += bytesRead;\n        if (err) {\n            this.emit('error', err);\n            this.push(null);\n        } else if (!bytesRead) {\n            this.push(null);\n        } else {\n            if (bytesRead !== buffer.length) {\n                buffer = buffer.slice(0, bytesRead);\n            }\n            this.push(buffer);\n        }\n    }\n}\n\nclass EntryVerifyStream extends stream.Transform {\n    constructor(baseStm, crc, size) {\n        super();\n        this.verify = new CrcVerify(crc, size);\n        baseStm.on('error', (e) => {\n            this.emit('error', e);\n        });\n    }\n\n    _transform(data, encoding, callback) {\n        let err;\n        try {\n            this.verify.data(data);\n        } catch (e) {\n            err = e;\n        }\n        callback(err, data);\n    }\n}\n\nclass CrcVerify {\n    constructor(crc, size) {\n        this.crc = crc;\n        this.size = size;\n        this.state = {\n            crc: ~0,\n            size: 0,\n        };\n    }\n\n    data(data) {\n        const crcTable = CrcVerify.getCrcTable();\n        let crc = this.state.crc;\n        let off = 0;\n        let len = data.length;\n        while (--len >= 0) {\n            crc = crcTable[(crc ^ data[off++]) & 0xff] ^ (crc >>> 8);\n        }\n        this.state.crc = crc;\n        this.state.size += data.length;\n        if (this.state.size >= this.size) {\n            const buf = Buffer.alloc(4);\n            buf.writeInt32LE(~this.state.crc & 0xffffffff, 0);\n            crc = buf.readUInt32LE(0);\n            if (crc !== this.crc) {\n                throw new Error('Invalid CRC');\n            }\n            if (this.state.size !== this.size) {\n                throw new Error('Invalid size');\n            }\n        }\n    }\n\n    static getCrcTable() {\n        let crcTable = CrcVerify.crcTable;\n        if (!crcTable) {\n            CrcVerify.crcTable = crcTable = [];\n            const b = Buffer.alloc(4);\n            for (let n = 0; n < 256; n++) {\n                let c = n;\n                for (let k = 8; --k >= 0; ) {\n                    if ((c & 1) !== 0) {\n                        c = 0xedb88320 ^ (c >>> 1);\n                    } else {\n                        c = c >>> 1;\n                    }\n                }\n                if (c < 0) {\n                    b.writeInt32LE(c, 0);\n                    c = b.readUInt32LE(0);\n                }\n                crcTable[n] = c;\n            }\n        }\n        return crcTable;\n    }\n}\n\nfunction parseZipTime(timebytes, datebytes) {\n    const timebits = toBits(timebytes, 16);\n    const datebits = toBits(datebytes, 16);\n\n    const mt = {\n        h: parseInt(timebits.slice(0, 5).join(''), 2),\n        m: parseInt(timebits.slice(5, 11).join(''), 2),\n        s: parseInt(timebits.slice(11, 16).join(''), 2) * 2,\n        Y: parseInt(datebits.slice(0, 7).join(''), 2) + 1980,\n        M: parseInt(datebits.slice(7, 11).join(''), 2),\n        D: parseInt(datebits.slice(11, 16).join(''), 2),\n    };\n    const dt_str = [mt.Y, mt.M, mt.D].join('-') + ' ' + [mt.h, mt.m, mt.s].join(':') + ' GMT+0';\n    return new Date(dt_str).getTime();\n}\n\nfunction toBits(dec, size) {\n    let b = (dec >>> 0).toString(2);\n    while (b.length < size) {\n        b = '0' + b;\n    }\n    return b.split('');\n}\n\nfunction readUInt64LE(buffer, offset) {\n    return buffer.readUInt32LE(offset + 4) * 0x0000000100000000 + buffer.readUInt32LE(offset);\n}\n\nmodule.exports = StreamZip;\n"]},"metadata":{},"sourceType":"script"}