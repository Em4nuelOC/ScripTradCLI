{"ast":null,"code":"//filter will reemit the data if cb(err,pass) pass is truthy\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\nvar Stream = require('stream').Stream; //create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\n\nmodule.exports = function (mapper, opts) {\n  var stream = new Stream(),\n      inputs = 0,\n      outputs = 0,\n      ended = false,\n      paused = false,\n      destroyed = false,\n      lastWritten = 0,\n      inNext = false;\n  opts = opts || {};\n  var errorEventName = opts.failures ? 'failure' : 'error'; // Items that are not ready to be written yet (because they would come out of\n  // order) get stuck in a queue for later.\n\n  var writeQueue = {};\n  stream.writable = true;\n  stream.readable = true;\n\n  function queueData(data, number) {\n    var nextToWrite = lastWritten + 1;\n\n    if (number === nextToWrite) {\n      // If it's next, and its not undefined write it\n      if (data !== undefined) {\n        stream.emit.apply(stream, ['data', data]);\n      }\n\n      lastWritten++;\n      nextToWrite++;\n    } else {\n      // Otherwise queue it for later.\n      writeQueue[number] = data;\n    } // If the next value is in the queue, write it\n\n\n    if (writeQueue.hasOwnProperty(nextToWrite)) {\n      var dataToWrite = writeQueue[nextToWrite];\n      delete writeQueue[nextToWrite];\n      return queueData(dataToWrite, nextToWrite);\n    }\n\n    outputs++;\n\n    if (inputs === outputs) {\n      if (paused) paused = false, stream.emit('drain'); //written all the incoming events\n\n      if (ended) end();\n    }\n  }\n\n  function next(err, data, number) {\n    if (destroyed) return;\n    inNext = true;\n\n    if (!err || opts.failures) {\n      queueData(data, number);\n    }\n\n    if (err) {\n      stream.emit.apply(stream, [errorEventName, err]);\n    }\n\n    inNext = false;\n  } // Wrap the mapper function by calling its callback with the order number of\n  // the item in the stream.\n\n\n  function wrappedMapper(input, number, callback) {\n    return mapper.call(null, input, function (err, data) {\n      callback(err, data, number);\n    });\n  }\n\n  stream.write = function (data) {\n    if (ended) throw new Error('map stream is not writable');\n    inNext = false;\n    inputs++;\n\n    try {\n      //catch sync errors and handle them like async errors\n      var written = wrappedMapper(data, inputs, next);\n      paused = written === false;\n      return !paused;\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if (inNext) throw err;\n      next(err);\n      return !paused;\n    }\n  };\n\n  function end(data) {\n    //if end was called with args, write it, \n    ended = true; //write will emit 'end' if ended is true\n\n    stream.writable = false;\n\n    if (data !== undefined) {\n      return queueData(data, inputs);\n    } else if (inputs == outputs) {\n      //wait for processing \n      stream.readable = false, stream.emit('end'), stream.destroy();\n    }\n  }\n\n  stream.end = function (data) {\n    if (ended) return;\n    end(data);\n  };\n\n  stream.destroy = function () {\n    ended = destroyed = true;\n    stream.writable = stream.readable = paused = false;\n    process.nextTick(function () {\n      stream.emit('close');\n    });\n  };\n\n  stream.pause = function () {\n    paused = true;\n  };\n\n  stream.resume = function () {\n    paused = false;\n  };\n\n  return stream;\n};","map":{"version":3,"sources":["E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/map-stream/index.js"],"names":["Stream","require","module","exports","mapper","opts","stream","inputs","outputs","ended","paused","destroyed","lastWritten","inNext","errorEventName","failures","writeQueue","writable","readable","queueData","data","number","nextToWrite","undefined","emit","apply","hasOwnProperty","dataToWrite","end","next","err","wrappedMapper","input","callback","call","write","Error","written","destroy","process","nextTick","pause","resume"],"mappings":"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","sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nmodule.exports = function (mapper, opts) {\n\n  var stream = new Stream()\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n    , lastWritten = 0\n    , inNext = false\n\n  opts = opts || {};\n  var errorEventName = opts.failures ? 'failure' : 'error';\n\n  // Items that are not ready to be written yet (because they would come out of\n  // order) get stuck in a queue for later.\n  var writeQueue = {}\n\n  stream.writable = true\n  stream.readable = true\n\n  function queueData (data, number) {\n    var nextToWrite = lastWritten + 1\n\n    if (number === nextToWrite) {\n      // If it's next, and its not undefined write it\n      if (data !== undefined) {\n        stream.emit.apply(stream, ['data', data])\n      }\n      lastWritten ++\n      nextToWrite ++\n    } else {\n      // Otherwise queue it for later.\n      writeQueue[number] = data\n    }\n\n    // If the next value is in the queue, write it\n    if (writeQueue.hasOwnProperty(nextToWrite)) {\n      var dataToWrite = writeQueue[nextToWrite]\n      delete writeQueue[nextToWrite]\n      return queueData(dataToWrite, nextToWrite)\n    }\n\n    outputs ++\n    if(inputs === outputs) {\n      if(paused) paused = false, stream.emit('drain') //written all the incoming events\n      if(ended) end()\n    }\n  }\n\n  function next (err, data, number) {\n    if(destroyed) return\n    inNext = true\n\n    if (!err || opts.failures) {\n      queueData(data, number)\n    }\n\n    if (err) {\n      stream.emit.apply(stream, [ errorEventName, err ]);\n    }\n\n    inNext = false;\n  }\n\n  // Wrap the mapper function by calling its callback with the order number of\n  // the item in the stream.\n  function wrappedMapper (input, number, callback) {\n    return mapper.call(null, input, function(err, data){\n      callback(err, data, number)\n    })\n  }\n\n  stream.write = function (data) {\n    if(ended) throw new Error('map stream is not writable')\n    inNext = false\n    inputs ++\n\n    try {\n      //catch sync errors and handle them like async errors\n      var written = wrappedMapper(data, inputs, next)\n      paused = (written === false)\n      return !paused\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return !paused\n    }\n  }\n\n  function end (data) {\n    //if end was called with args, write it, \n    ended = true //write will emit 'end' if ended is true\n    stream.writable = false\n    if(data !== undefined) {\n      return queueData(data, inputs)\n    } else if (inputs == outputs) { //wait for processing \n      stream.readable = false, stream.emit('end'), stream.destroy() \n    }\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    end(data)\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n    process.nextTick(function () {\n      stream.emit('close')\n    })\n  }\n  stream.pause = function () {\n    paused = true\n  }\n\n  stream.resume = function () {\n    paused = false\n  }\n\n  return stream\n}\n\n\n\n\n"]},"metadata":{},"sourceType":"script"}