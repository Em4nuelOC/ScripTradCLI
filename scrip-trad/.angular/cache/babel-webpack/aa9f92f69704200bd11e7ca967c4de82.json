{"ast":null,"code":"/* eslint-disable */\n// Copyright (c) 2012 Chris Geiersbach\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n// This component as adapted from node-ole-doc, available at:\n// https://github.com/atariman486/node-ole-doc.\n//\n// WARNING: This embedded component will be removed in a future\n// release. It is only included as there are some fixes which\n// are not yet pushed into the npm distribution of node-ole-doc.\nvar fs = require('fs');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar async = require('async');\n\nvar _ = require('underscore');\n\nvar es = require('event-stream');\n\nfunction Header() {}\n\n;\nHeader.ole_id = new Buffer('D0CF11E0A1B11AE1', 'hex');\n\nHeader.prototype.load = function (buffer) {\n  var i;\n\n  for (i = 0; i < 8; i++) {\n    if (Header.ole_id[i] != buffer[i]) return false;\n  }\n\n  this.secSize = 1 << buffer.readInt16LE(30); // Size of sectors\n\n  this.shortSecSize = 1 << buffer.readInt16LE(32); // Size of short sectors\n\n  this.SATSize = buffer.readInt32LE(44); // Number of sectors used for the Sector Allocation Table\n\n  this.dirSecId = buffer.readInt32LE(48); // Starting Sec ID of the directory stream\n\n  this.shortStreamMax = buffer.readInt32LE(56); // Maximum size of a short stream\n\n  this.SSATSecId = buffer.readInt32LE(60); // Starting Sec ID of the Short Sector Allocation Table\n\n  this.SSATSize = buffer.readInt32LE(64); // Number of sectors used for the Short Sector Allocation Table\n\n  this.MSATSecId = buffer.readInt32LE(68); // Starting Sec ID of the Master Sector Allocation Table\n\n  this.MSATSize = buffer.readInt32LE(72); // Number of sectors used for the Master Sector Allocation Table\n  // The first 109 sectors of the MSAT\n\n  this.partialMSAT = new Array(109);\n\n  for (i = 0; i < 109; i++) this.partialMSAT[i] = buffer.readInt32LE(76 + i * 4);\n\n  return true;\n};\n\nfunction AllocationTable(doc) {\n  this._doc = doc;\n}\n\nAllocationTable.SecIdFree = -1;\nAllocationTable.SecIdEndOfChain = -2;\nAllocationTable.SecIdSAT = -3;\nAllocationTable.SecIdMSAT = -4;\n\nAllocationTable.prototype.load = function (secIds, callback) {\n  var self = this;\n  var doc = self._doc;\n  var header = doc._header;\n  self._table = new Array(secIds.length * (header.secSize / 4));\n\n  doc._readSectors(secIds, function (buffer) {\n    var i;\n\n    for (i = 0; i < buffer.length / 4; i++) {\n      self._table[i] = buffer.readInt32LE(i * 4);\n    }\n\n    callback();\n  });\n};\n\nAllocationTable.prototype.getSecIdChain = function (startSecId) {\n  var secId = startSecId;\n  var secIds = [];\n\n  while (secId > AllocationTable.SecIdFree) {\n    secIds.push(secId);\n    var secIdPrior = secId;\n    secId = this._table[secId];\n\n    if (secId === secIdPrior) {\n      // this will cause a deadlock and a out of memory error\n      break;\n    }\n  }\n\n  return secIds;\n};\n\nfunction DirectoryTree(doc) {\n  this._doc = doc;\n}\n\nDirectoryTree.EntryTypeEmpty = 0;\nDirectoryTree.EntryTypeStorage = 1;\nDirectoryTree.EntryTypeStream = 2;\nDirectoryTree.EntryTypeRoot = 5;\nDirectoryTree.NodeColorRed = 0;\nDirectoryTree.NodeColorBlack = 1;\nDirectoryTree.Leaf = -1;\n\nDirectoryTree.prototype.load = function (secIds, callback) {\n  var self = this;\n  var doc = this._doc;\n\n  doc._readSectors(secIds, function (buffer) {\n    var count = buffer.length / 128;\n    self._entries = new Array(count);\n    var i = 0;\n\n    for (i = 0; i < count; i++) {\n      var offset = i * 128;\n      var nameLength = Math.max(buffer.readInt16LE(64 + offset) - 1, 0);\n      var entry = {};\n      entry.name = buffer.toString('utf16le', 0 + offset, nameLength + offset);\n      entry.type = buffer.readInt8(66 + offset);\n      entry.nodeColor = buffer.readInt8(67 + offset);\n      entry.left = buffer.readInt32LE(68 + offset);\n      entry.right = buffer.readInt32LE(72 + offset);\n      entry.storageDirId = buffer.readInt32LE(76 + offset);\n      entry.secId = buffer.readInt32LE(116 + offset);\n      entry.size = buffer.readInt32LE(120 + offset);\n      self._entries[i] = entry;\n    }\n\n    self.root = _.find(self._entries, function (entry) {\n      return entry.type === DirectoryTree.EntryTypeRoot;\n    });\n\n    self._buildHierarchy(self.root);\n\n    callback();\n  });\n};\n\nDirectoryTree.prototype._buildHierarchy = function (storageEntry) {\n  var self = this;\n\n  var childIds = this._getChildIds(storageEntry);\n\n  storageEntry.storages = {};\n  storageEntry.streams = {};\n\n  _.each(childIds, function (childId) {\n    var childEntry = self._entries[childId];\n    var name = childEntry.name;\n\n    if (childEntry.type === DirectoryTree.EntryTypeStorage) {\n      storageEntry.storages[name] = childEntry;\n    }\n\n    if (childEntry.type === DirectoryTree.EntryTypeStream) {\n      storageEntry.streams[name] = childEntry;\n    }\n  });\n\n  _.each(storageEntry.storages, function (childStorageEntry) {\n    self._buildHierarchy(childStorageEntry);\n  });\n};\n\nDirectoryTree.prototype._getChildIds = function (storageEntry) {\n  var self = this;\n  var childIds = [];\n\n  function visit(visitEntry) {\n    if (visitEntry.left !== DirectoryTree.Leaf) {\n      childIds.push(visitEntry.left);\n      visit(self._entries[visitEntry.left]);\n    }\n\n    if (visitEntry.right !== DirectoryTree.Leaf) {\n      childIds.push(visitEntry.right);\n      visit(self._entries[visitEntry.right]);\n    }\n  }\n\n  ;\n\n  if (storageEntry.storageDirId > -1) {\n    childIds.push(storageEntry.storageDirId);\n    var rootChildEntry = self._entries[storageEntry.storageDirId];\n    visit(rootChildEntry);\n  }\n\n  return childIds;\n};\n\nfunction Storage(doc, dirEntry) {\n  this._doc = doc;\n  this._dirEntry = dirEntry;\n}\n\n;\n\nStorage.prototype.storage = function (storageName) {\n  return new Storage(this._doc, this._dirEntry.storages[storageName]);\n};\n\nStorage.prototype.stream = function (streamName) {\n  var streamEntry = this._dirEntry.streams[streamName];\n  if (!streamEntry) return null;\n  var self = this;\n  var doc = self._doc;\n  var bytes = streamEntry.size;\n  var allocationTable = doc._SAT;\n  var shortStream = false;\n\n  if (bytes < doc._header.shortStreamMax) {\n    shortStream = true;\n    allocationTable = doc._SSAT;\n  }\n\n  var secIds = allocationTable.getSecIdChain(streamEntry.secId);\n  return es.readable(function (i, callback) {\n    var stream = this; // Function called in context of stream\n\n    if (i >= secIds.length) {\n      stream.emit('end');\n      return;\n    }\n\n    function sectorCallback(buffer) {\n      if (bytes - buffer.length < 0) {\n        buffer = buffer.slice(0, bytes);\n      }\n\n      bytes -= buffer.length;\n      stream.emit('data', buffer);\n      callback();\n    }\n\n    ;\n\n    if (shortStream) {\n      doc._readShortSector(secIds[i], sectorCallback);\n    } else {\n      doc._readSector(secIds[i], sectorCallback);\n    }\n  });\n}; //function Stream( doc, dirEntry ) {\n//   this._doc = doc;\n//   this._dirEntry = dirEntry;\n//};\n\n\nfunction OleCompoundDoc(filename) {\n  EventEmitter.call(this);\n  this._filename = filename;\n  this._skipBytes = 0;\n}\n\n;\nutil.inherits(OleCompoundDoc, EventEmitter);\n\nOleCompoundDoc.prototype.read = function () {\n  this._read();\n};\n\nOleCompoundDoc.prototype.readWithCustomHeader = function (size, callback) {\n  this._skipBytes = size;\n  this._customHeaderCallback = callback;\n\n  this._read();\n};\n\nOleCompoundDoc.prototype._read = function () {\n  var series = [this._openFile.bind(this), this._readHeader.bind(this), this._readMSAT.bind(this), this._readSAT.bind(this), this._readSSAT.bind(this), this._readDirectoryTree.bind(this)];\n\n  if (this._skipBytes != 0) {\n    series.splice(1, 0, this._readCustomHeader.bind(this));\n  }\n\n  async.series(series, function (err) {\n    if (err) {\n      this.emit('err', err);\n      return;\n    }\n\n    this.emit('ready');\n  }.bind(this));\n};\n\nOleCompoundDoc.prototype._openFile = function (callback) {\n  var self = this;\n  fs.open(this._filename, 'r', 0o666, function (err, fd) {\n    if (err) {\n      self.emit('err', err);\n      return;\n    }\n\n    self._fd = fd;\n    callback();\n  });\n};\n\nOleCompoundDoc.prototype._readCustomHeader = function (callback) {\n  var self = this;\n  var buffer = new Buffer(this._skipBytes);\n  fs.read(self._fd, buffer, 0, this._skipBytes, 0, function (err, bytesRead, buffer) {\n    if (err) {\n      self.emit('err', err);\n      return;\n    }\n\n    if (!self._customHeaderCallback(buffer)) return;\n    callback();\n  });\n};\n\nOleCompoundDoc.prototype._readHeader = function (callback) {\n  var self = this;\n  var buffer = new Buffer(512);\n  fs.read(this._fd, buffer, 0, 512, 0 + this._skipBytes, function (err, bytesRead, buffer) {\n    if (err) {\n      self.emit('err', err);\n      return;\n    }\n\n    var header = self._header = new Header();\n\n    if (!header.load(buffer)) {\n      self.emit('err', new Error(\"Not a valid compound document\"));\n      return;\n    }\n\n    callback();\n  });\n};\n\nOleCompoundDoc.prototype._readMSAT = function (callback) {\n  var self = this;\n  var header = self._header;\n  self._MSAT = header.partialMSAT.slice(0);\n  self._MSAT.length = header.SATSize;\n\n  if (header.SATSize <= 109 || header.MSATSize == 0) {\n    callback();\n    return;\n  }\n\n  var buffer = new Buffer(header.secSize);\n  var currMSATIndex = 109;\n  var i = 0;\n  var secId = header.MSATSecId;\n  async.whilst(function () {\n    return i < header.MSATSize;\n  }, function (whilstCallback) {\n    self._readSector(secId, function (sectorBuffer) {\n      var s;\n\n      for (s = 0; s < header.secSize - 4; s += 4) {\n        if (currMSATIndex >= header.SATSize) break;else self._MSAT[currMSATIndex] = sectorBuffer.readInt32LE(s);\n        currMSATIndex++;\n      }\n\n      secId = sectorBuffer.readInt32LE(header.secSize - 4);\n      i++;\n      whilstCallback();\n    });\n  }, function (err) {\n    if (err) {\n      self.emit('err', err);\n      return;\n    }\n\n    callback();\n  });\n};\n\nOleCompoundDoc.prototype._readSector = function (secId, callback) {\n  this._readSectors([secId], callback);\n};\n\nOleCompoundDoc.prototype._readSectors = function (secIds, callback) {\n  var self = this;\n  var header = self._header;\n  var buffer = new Buffer(secIds.length * header.secSize);\n  var i = 0;\n  async.whilst(function () {\n    return i < secIds.length;\n  }, function (whilstCallback) {\n    var bufferOffset = i * header.secSize;\n\n    var fileOffset = self._getFileOffsetForSec(secIds[i]);\n\n    fs.read(self._fd, buffer, bufferOffset, header.secSize, fileOffset, function (err, bytesRead, buffer) {\n      if (err) {\n        self.emit('err', err);\n        return;\n      }\n\n      i++;\n      whilstCallback();\n    });\n  }, function (err) {\n    if (err) {\n      self.emit('err', err);\n    }\n\n    callback(buffer);\n  });\n};\n\nOleCompoundDoc.prototype._readShortSector = function (secId, callback) {\n  this._readShortSectors([secId], callback);\n};\n\nOleCompoundDoc.prototype._readShortSectors = function (secIds, callback) {\n  var self = this;\n  var header = self._header;\n  var buffer = new Buffer(secIds.length * header.shortSecSize);\n  var i = 0;\n  async.whilst(function () {\n    return i < secIds.length;\n  }, function (whilstCallback) {\n    var bufferOffset = i * header.shortSecSize;\n\n    var fileOffset = self._getFileOffsetForShortSec(secIds[i]);\n\n    fs.read(self._fd, buffer, bufferOffset, header.shortSecSize, fileOffset, function (err, bytesRead, buffer) {\n      if (err) {\n        self.emit('err', err);\n        return;\n      }\n\n      i++;\n      whilstCallback();\n    });\n  }, function (err) {\n    if (err) {\n      self.emit('err', err);\n    }\n\n    callback(buffer);\n  });\n};\n\nOleCompoundDoc.prototype._readSAT = function (callback) {\n  var self = this;\n  self._SAT = new AllocationTable(self);\n\n  self._SAT.load(self._MSAT, callback);\n};\n\nOleCompoundDoc.prototype._readSSAT = function (callback) {\n  var self = this;\n  var header = self._header;\n  self._SSAT = new AllocationTable(self);\n\n  var secIds = self._SAT.getSecIdChain(header.SSATSecId);\n\n  if (secIds.length != header.SSATSize) {\n    self.emit('err', new Error(\"Invalid Short Sector Allocation Table\"));\n    return;\n  }\n\n  self._SSAT.load(secIds, callback);\n};\n\nOleCompoundDoc.prototype._readDirectoryTree = function (callback) {\n  var self = this;\n  var header = self._header;\n  self._directoryTree = new DirectoryTree(this);\n\n  var secIds = self._SAT.getSecIdChain(header.dirSecId);\n\n  self._directoryTree.load(secIds, function () {\n    var rootEntry = self._directoryTree.root;\n    self._rootStorage = new Storage(self, rootEntry);\n    self._shortStreamSecIds = self._SAT.getSecIdChain(rootEntry.secId);\n    callback();\n  });\n};\n\nOleCompoundDoc.prototype._getFileOffsetForSec = function (secId) {\n  var secSize = this._header.secSize;\n  return this._skipBytes + (secId + 1) * secSize; // Skip past the header sector\n};\n\nOleCompoundDoc.prototype._getFileOffsetForShortSec = function (shortSecId) {\n  var shortSecSize = this._header.shortSecSize;\n  var shortStreamOffset = shortSecId * shortSecSize;\n  var secSize = this._header.secSize;\n  var secIdIndex = Math.floor(shortStreamOffset / secSize);\n  var secOffset = shortStreamOffset % secSize;\n  var secId = this._shortStreamSecIds[secIdIndex];\n  return this._getFileOffsetForSec(secId) + secOffset;\n};\n\nOleCompoundDoc.prototype.storage = function (storageName) {\n  return this._rootStorage.storage(storageName);\n};\n\nOleCompoundDoc.prototype.stream = function (streamName) {\n  return this._rootStorage.stream(streamName);\n};\n\nexports.OleCompoundDoc = OleCompoundDoc;","map":{"version":3,"sources":["C:/Users/CND12816RD/Desktop/Sabrina/github/Scriptrad/ScripTradCLI/scrip-trad/node_modules/word-extractor/lib/ole-doc.js"],"names":["fs","require","EventEmitter","util","async","_","es","Header","ole_id","Buffer","prototype","load","buffer","i","secSize","readInt16LE","shortSecSize","SATSize","readInt32LE","dirSecId","shortStreamMax","SSATSecId","SSATSize","MSATSecId","MSATSize","partialMSAT","Array","AllocationTable","doc","_doc","SecIdFree","SecIdEndOfChain","SecIdSAT","SecIdMSAT","secIds","callback","self","header","_header","_table","length","_readSectors","getSecIdChain","startSecId","secId","push","secIdPrior","DirectoryTree","EntryTypeEmpty","EntryTypeStorage","EntryTypeStream","EntryTypeRoot","NodeColorRed","NodeColorBlack","Leaf","count","_entries","offset","nameLength","Math","max","entry","name","toString","type","readInt8","nodeColor","left","right","storageDirId","size","root","find","_buildHierarchy","storageEntry","childIds","_getChildIds","storages","streams","each","childId","childEntry","childStorageEntry","visit","visitEntry","rootChildEntry","Storage","dirEntry","_dirEntry","storage","storageName","stream","streamName","streamEntry","bytes","allocationTable","_SAT","shortStream","_SSAT","readable","emit","sectorCallback","slice","_readShortSector","_readSector","OleCompoundDoc","filename","call","_filename","_skipBytes","inherits","read","_read","readWithCustomHeader","_customHeaderCallback","series","_openFile","bind","_readHeader","_readMSAT","_readSAT","_readSSAT","_readDirectoryTree","splice","_readCustomHeader","err","open","fd","_fd","bytesRead","Error","_MSAT","currMSATIndex","whilst","whilstCallback","sectorBuffer","s","bufferOffset","fileOffset","_getFileOffsetForSec","_readShortSectors","_getFileOffsetForShortSec","_directoryTree","rootEntry","_rootStorage","_shortStreamSecIds","shortSecId","shortStreamOffset","secIdIndex","floor","secOffset","exports"],"mappings":"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","sourcesContent":["/* eslint-disable */\n// Copyright (c) 2012 Chris Geiersbach\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n// This component as adapted from node-ole-doc, available at:\n// https://github.com/atariman486/node-ole-doc.\n//\n// WARNING: This embedded component will be removed in a future\n// release. It is only included as there are some fixes which\n// are not yet pushed into the npm distribution of node-ole-doc.\n\nvar fs = require('fs');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar async = require('async');\nvar _ = require('underscore');\nvar es = require('event-stream');\n\nfunction Header() {\n};\n\nHeader.ole_id = new Buffer( 'D0CF11E0A1B11AE1', 'hex' );\n\nHeader.prototype.load = function( buffer ) {\n   var i;\n   for( i = 0; i < 8; i++ ) {\n      if ( Header.ole_id[i] != buffer[i] )\n         return false;\n   }\n\n   this.secSize        = 1 << buffer.readInt16LE( 30 );  // Size of sectors\n   this.shortSecSize   = 1 << buffer.readInt16LE( 32 );  // Size of short sectors\n   this.SATSize        =      buffer.readInt32LE( 44 );  // Number of sectors used for the Sector Allocation Table\n   this.dirSecId       =      buffer.readInt32LE( 48 );  // Starting Sec ID of the directory stream\n   this.shortStreamMax =      buffer.readInt32LE( 56 );  // Maximum size of a short stream\n   this.SSATSecId      =      buffer.readInt32LE( 60 );  // Starting Sec ID of the Short Sector Allocation Table\n   this.SSATSize       =      buffer.readInt32LE( 64 );  // Number of sectors used for the Short Sector Allocation Table\n   this.MSATSecId      =      buffer.readInt32LE( 68 );  // Starting Sec ID of the Master Sector Allocation Table\n   this.MSATSize       =      buffer.readInt32LE( 72 );  // Number of sectors used for the Master Sector Allocation Table\n\n   // The first 109 sectors of the MSAT\n   this.partialMSAT = new Array(109);\n   for( i = 0; i < 109; i++ )\n      this.partialMSAT[i] = buffer.readInt32LE( 76 + i * 4 );\n\n   return true;\n};\n\nfunction AllocationTable(doc) {\n   this._doc = doc;\n}\n\nAllocationTable.SecIdFree       = -1;\nAllocationTable.SecIdEndOfChain = -2;\nAllocationTable.SecIdSAT        = -3;\nAllocationTable.SecIdMSAT       = -4;\n\nAllocationTable.prototype.load = function(secIds, callback) {\n   var self = this;\n   var doc = self._doc;\n   var header = doc._header;\n\n   self._table = new Array( secIds.length * ( header.secSize / 4 ) );\n\n   doc._readSectors( secIds, function(buffer) {\n      var i;\n      for ( i = 0; i < buffer.length / 4; i++ ) {\n         self._table[i] = buffer.readInt32LE( i * 4 );\n      }\n      callback();\n   });\n};\n\nAllocationTable.prototype.getSecIdChain = function(startSecId) {\n   var secId = startSecId;\n   var secIds = [];\n   while ( secId > AllocationTable.SecIdFree ) {\n      secIds.push( secId );\n      var secIdPrior = secId;\n      secId = this._table[secId];\n      if (secId === secIdPrior) { // this will cause a deadlock and a out of memory error\n         break;\n      }\n   }\n\n   return secIds;\n};\n\nfunction DirectoryTree(doc) {\n   this._doc = doc;\n}\n\nDirectoryTree.EntryTypeEmpty   = 0;\nDirectoryTree.EntryTypeStorage = 1;\nDirectoryTree.EntryTypeStream  = 2;\nDirectoryTree.EntryTypeRoot    = 5;\n\nDirectoryTree.NodeColorRed   = 0;\nDirectoryTree.NodeColorBlack = 1;\n\nDirectoryTree.Leaf = -1;\n\nDirectoryTree.prototype.load = function( secIds, callback ) {\n   var self = this;\n   var doc = this._doc;\n\n   doc._readSectors( secIds, function(buffer) {\n\n      var count = buffer.length / 128;\n      self._entries = new Array( count );\n      var i = 0;\n      for( i = 0; i < count; i++ )\n      {\n         var offset = i * 128;\n\n         var nameLength = Math.max( buffer.readInt16LE( 64 + offset ) - 1, 0 );\n\n         var entry = {};\n         entry.name = buffer.toString('utf16le', 0 + offset, nameLength + offset );\n         entry.type = buffer.readInt8( 66 + offset );\n         entry.nodeColor = buffer.readInt8( 67 + offset );\n         entry.left = buffer.readInt32LE( 68 + offset );\n         entry.right = buffer.readInt32LE( 72 + offset );\n         entry.storageDirId = buffer.readInt32LE( 76 + offset );\n         entry.secId = buffer.readInt32LE( 116 + offset );\n         entry.size = buffer.readInt32LE( 120 + offset );\n\n         self._entries[i] = entry;\n      }\n\n      self.root = _.find( self._entries, function(entry) {\n         return entry.type === DirectoryTree.EntryTypeRoot;\n      });\n\n      self._buildHierarchy( self.root );\n\n      callback();\n   });\n};\n\nDirectoryTree.prototype._buildHierarchy = function( storageEntry ) {\n   var self = this;\n   var childIds = this._getChildIds( storageEntry );\n\n   storageEntry.storages = {};\n   storageEntry.streams  = {};\n\n   _.each( childIds, function( childId ) {\n      var childEntry = self._entries[childId];\n      var name = childEntry.name;\n      if ( childEntry.type === DirectoryTree.EntryTypeStorage ) {\n         storageEntry.storages[name] = childEntry;\n      }\n      if ( childEntry.type === DirectoryTree.EntryTypeStream ) {\n         storageEntry.streams[name] = childEntry;\n      }\n   });\n\n   _.each( storageEntry.storages, function( childStorageEntry ) {\n      self._buildHierarchy( childStorageEntry );\n   });\n};\n\nDirectoryTree.prototype._getChildIds = function( storageEntry ) {\n   var self = this;\n   var childIds = [];\n\n   function visit( visitEntry ) {\n      if ( visitEntry.left !== DirectoryTree.Leaf ) {\n         childIds.push( visitEntry.left );\n         visit( self._entries[visitEntry.left] );\n      }\n      if ( visitEntry.right !== DirectoryTree.Leaf ) {\n         childIds.push( visitEntry.right );\n         visit( self._entries[visitEntry.right] );\n      }\n   };\n\n   if ( storageEntry.storageDirId > -1 ) {\n      childIds.push( storageEntry.storageDirId );\n      var rootChildEntry = self._entries[storageEntry.storageDirId];\n      visit( rootChildEntry );\n   }\n\n   return childIds;\n};\n\nfunction Storage( doc, dirEntry ) {\n   this._doc = doc;\n   this._dirEntry = dirEntry;\n};\n\nStorage.prototype.storage = function( storageName ) {\n   return new Storage( this._doc, this._dirEntry.storages[ storageName ] );\n};\n\nStorage.prototype.stream = function( streamName ) {\n   var streamEntry = this._dirEntry.streams[streamName];\n   if ( !streamEntry )\n      return null;\n\n   var self = this;\n   var doc  = self._doc;\n   var bytes = streamEntry.size;\n\n   var allocationTable = doc._SAT;\n   var shortStream = false;\n   if ( bytes < doc._header.shortStreamMax ) {\n      shortStream = true;\n      allocationTable = doc._SSAT;\n   }\n\n   var secIds = allocationTable.getSecIdChain( streamEntry.secId );\n\n   return es.readable( function( i, callback ) {\n      var stream = this;  // Function called in context of stream\n\n      if ( i >= secIds.length ) {\n         stream.emit('end');\n         return;\n      }\n\n      function sectorCallback(buffer) {\n         if ( bytes - buffer.length < 0 ) {\n            buffer = buffer.slice( 0, bytes );\n         }\n\n         bytes -= buffer.length;\n         stream.emit('data', buffer);\n         callback();\n      };\n\n      if ( shortStream ) {\n         doc._readShortSector( secIds[i], sectorCallback );\n      }\n      else {\n         doc._readSector( secIds[i], sectorCallback );\n      }\n   });\n};\n\n//function Stream( doc, dirEntry ) {\n//   this._doc = doc;\n//   this._dirEntry = dirEntry;\n//};\n\nfunction OleCompoundDoc( filename ) {\n   EventEmitter.call(this);\n\n   this._filename = filename;\n   this._skipBytes = 0;\n};\nutil.inherits(OleCompoundDoc, EventEmitter);\n\nOleCompoundDoc.prototype.read = function() {\n   this._read();\n};\n\nOleCompoundDoc.prototype.readWithCustomHeader = function( size, callback ) {\n   this._skipBytes = size;\n   this._customHeaderCallback = callback;\n   this._read();\n};\n\nOleCompoundDoc.prototype._read = function() {\n   var series = [\n      this._openFile.bind(this),\n      this._readHeader.bind(this),\n      this._readMSAT.bind(this),\n      this._readSAT.bind(this),\n      this._readSSAT.bind(this),\n      this._readDirectoryTree.bind(this)\n   ];\n\n   if ( this._skipBytes != 0 ) {\n      series.splice( 1, 0, this._readCustomHeader.bind(this) );\n   }\n\n   async.series(\n      series,\n      (function(err) {\n         if ( err ) {\n            this.emit('err', err);\n            return;\n         }\n\n         this.emit('ready');\n      }).bind(this)\n   );\n};\n\nOleCompoundDoc.prototype._openFile = function( callback ) {\n   var self = this;\n   fs.open( this._filename, 'r', 0o666, function(err, fd) {\n      if( err ) {\n         self.emit('err', err);\n         return;\n      }\n\n      self._fd = fd;\n      callback();\n   });\n};\n\nOleCompoundDoc.prototype._readCustomHeader = function(callback) {\n   var self = this;\n   var buffer = new Buffer(this._skipBytes);\n   fs.read( self._fd, buffer, 0, this._skipBytes, 0, function(err, bytesRead, buffer) {\n      if(err) {\n         self.emit('err', err);\n         return;\n      }\n\n      if( !self._customHeaderCallback(buffer) )\n         return;\n\n      callback();\n   });\n};\n\nOleCompoundDoc.prototype._readHeader = function(callback) {\n   var self = this;\n   var buffer = new Buffer(512);\n   fs.read( this._fd, buffer, 0, 512, 0 + this._skipBytes, function(err, bytesRead, buffer) {\n      if( err ) {\n         self.emit('err', err);\n         return;\n      }\n\n      var header = self._header = new Header();\n      if ( !header.load( buffer ) ) {\n         self.emit('err', new Error(\"Not a valid compound document\"));\n         return;\n      }\n\n      callback();\n   });\n};\n\nOleCompoundDoc.prototype._readMSAT = function(callback) {\n   var self = this;\n   var header = self._header;\n\n   self._MSAT = header.partialMSAT.slice(0);\n   self._MSAT.length = header.SATSize;\n\n   if( header.SATSize <= 109 || header.MSATSize == 0 ) {\n      callback();\n      return;\n   }\n\n   var buffer = new Buffer( header.secSize );\n   var currMSATIndex = 109;\n   var i = 0;\n   var secId = header.MSATSecId;\n\n   async.whilst(\n      function() {\n         return i < header.MSATSize;\n      },\n      function(whilstCallback) {\n         self._readSector(secId, function(sectorBuffer) {\n            var s;\n            for( s = 0; s < header.secSize - 4; s += 4 )\n            {\n               if( currMSATIndex >= header.SATSize )\n                  break;\n               else\n                  self._MSAT[currMSATIndex] = sectorBuffer.readInt32LE( s );\n\n               currMSATIndex++;\n            }\n\n            secId = sectorBuffer.readInt32LE( header.secSize - 4 );\n            i++;\n            whilstCallback();\n         });\n      },\n      function(err) {\n         if ( err ) {\n            self.emit('err', err);\n            return;\n         }\n\n         callback();\n      }\n   );\n};\n\nOleCompoundDoc.prototype._readSector = function(secId, callback) {\n   this._readSectors( [ secId ], callback );\n};\n\nOleCompoundDoc.prototype._readSectors = function(secIds, callback) {\n   var self = this;\n   var header = self._header;\n   var buffer = new Buffer( secIds.length * header.secSize );\n\n   var i = 0;\n\n   async.whilst(\n      function() {\n         return i < secIds.length;\n      },\n      function(whilstCallback) {\n         var bufferOffset = i * header.secSize;\n         var fileOffset = self._getFileOffsetForSec( secIds[i] );\n         fs.read( self._fd, buffer, bufferOffset, header.secSize, fileOffset, function(err, bytesRead, buffer) {\n            if ( err ) {\n               self.emit('err', err);\n               return;\n            }\n            i++;\n            whilstCallback();\n         });\n      },\n      function(err) {\n         if ( err ) {\n            self.emit('err', err);\n         }\n         callback(buffer);\n      }\n   );\n};\n\nOleCompoundDoc.prototype._readShortSector = function(secId, callback) {\n   this._readShortSectors( [ secId ], callback );\n};\n\nOleCompoundDoc.prototype._readShortSectors = function(secIds, callback) {\n   var self = this;\n   var header = self._header;\n   var buffer = new Buffer( secIds.length * header.shortSecSize );\n\n   var i = 0;\n\n   async.whilst(\n      function() {\n         return i < secIds.length;\n      },\n      function(whilstCallback) {\n         var bufferOffset = i * header.shortSecSize;\n         var fileOffset = self._getFileOffsetForShortSec( secIds[i] );\n         fs.read( self._fd, buffer, bufferOffset, header.shortSecSize, fileOffset, function(err, bytesRead, buffer) {\n            if ( err ) {\n               self.emit('err', err);\n               return;\n            }\n            i++;\n            whilstCallback();\n         });\n      },\n      function(err) {\n         if ( err ) {\n            self.emit('err', err);\n         }\n         callback(buffer);\n      }\n   );\n};\n\nOleCompoundDoc.prototype._readSAT = function(callback) {\n   var self = this;\n   self._SAT = new AllocationTable(self);\n\n   self._SAT.load( self._MSAT, callback );\n};\n\nOleCompoundDoc.prototype._readSSAT = function(callback) {\n   var self = this;\n   var header = self._header;\n   self._SSAT = new AllocationTable(self);\n\n   var secIds = self._SAT.getSecIdChain( header.SSATSecId );\n   if ( secIds.length != header.SSATSize ) {\n      self.emit('err', new Error(\"Invalid Short Sector Allocation Table\"));\n      return;\n   }\n\n   self._SSAT.load( secIds, callback);\n};\n\nOleCompoundDoc.prototype._readDirectoryTree = function(callback) {\n   var self = this;\n   var header = self._header;\n\n   self._directoryTree = new DirectoryTree(this);\n\n   var secIds = self._SAT.getSecIdChain( header.dirSecId );\n   self._directoryTree.load( secIds, function() {\n\n      var rootEntry = self._directoryTree.root;\n      self._rootStorage = new Storage( self, rootEntry );\n      self._shortStreamSecIds = self._SAT.getSecIdChain( rootEntry.secId );\n\n      callback();\n   });\n};\n\nOleCompoundDoc.prototype._getFileOffsetForSec = function( secId ) {\n   var secSize = this._header.secSize;\n   return this._skipBytes + (secId + 1) * secSize;  // Skip past the header sector\n};\n\nOleCompoundDoc.prototype._getFileOffsetForShortSec = function( shortSecId ) {\n   var shortSecSize = this._header.shortSecSize;\n   var shortStreamOffset = shortSecId * shortSecSize;\n\n   var secSize = this._header.secSize;\n   var secIdIndex = Math.floor( shortStreamOffset / secSize );\n   var secOffset = shortStreamOffset % secSize;\n   var secId = this._shortStreamSecIds[secIdIndex];\n\n   return this._getFileOffsetForSec( secId ) + secOffset;\n};\n\nOleCompoundDoc.prototype.storage = function( storageName ) {\n   return this._rootStorage.storage( storageName );\n};\n\nOleCompoundDoc.prototype.stream = function( streamName ) {\n   return this._rootStorage.stream( streamName );\n};\n\nexports.OleCompoundDoc = OleCompoundDoc;\n"]},"metadata":{},"sourceType":"script"}