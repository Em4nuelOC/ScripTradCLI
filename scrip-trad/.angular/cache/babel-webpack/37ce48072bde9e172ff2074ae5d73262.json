{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst JSZip = require('jszip');\n\nconst convert = require('xml-js');\n/**\r\n * Load and Extract given docx file\r\n */\n\n\nfunction loadFile(_x) {\n  return _loadFile.apply(this, arguments);\n}\n/**\r\n * Main Logic for extracting Table data from XML JSON data\r\n */\n\n\nfunction _loadFile() {\n  _loadFile = _asyncToGenerator(function* (file) {\n    return new Promise((resolve, reject) => {\n      fs.readFile(file, function (err, data) {\n        if (err) {\n          reject(err);\n        }\n\n        JSZip.loadAsync(data).then(function (zip) {\n          resolve(zip);\n        }).catch(error => {\n          reject(error);\n        });\n      });\n    });\n  });\n  return _loadFile.apply(this, arguments);\n}\n\nfunction parseTables(xmlJsonData) {\n  const tables = [];\n\n  try {\n    let wTable = xmlJsonData['w:document']['w:body']['w:tbl'];\n\n    if (wTable) {\n      if (wTable.constructor !== [].constructor) {\n        wTable = [wTable];\n      }\n\n      wTable.forEach(wTableItem => {\n        const result = {};\n        const wTableItemRow = wTableItem['w:tr'];\n        wTableItemRow.forEach((wTableItemRowItem, rowIndex) => {\n          const wTableItemRowColumn = wTableItemRowItem['w:tc'];\n          const rowObject = [];\n          wTableItemRowColumn.forEach((wTableItemRowColumnItem, colIndex) => {\n            let wp = wTableItemRowColumnItem['w:p'];\n\n            if (wp) {\n              if (wp.constructor !== [].constructor) {\n                wp = [wp];\n              }\n\n              let data = '';\n              wp.forEach(wpItem => {\n                if (wpItem['w:r'] && wpItem['w:r']['w:t'] && wpItem['w:r']['w:t']._text) {\n                  data += `${wpItem['w:r']['w:t']._text}\\n`;\n                }\n              }); //if (data) {\n\n              rowObject.push({\n                position: {\n                  row: rowIndex,\n                  col: colIndex\n                },\n                data\n              }); //}\n            } // console.log('++++++++++++++++++')\n\n          }); //if (rowObject && rowObject.constructor === [].constructor && rowObject.length > 0) {\n\n          result[`${rowIndex}`] = Object.assign([], rowObject); //}\n          // console.log('==========================')\n        });\n        tables.push(result);\n      });\n    }\n  } catch (error) {\n    return error;\n  }\n\n  return tables;\n}\n\nmodule.exports = function (props) {\n  return new Promise((resolve, reject) => {\n    if (!(props && props.constructor === {}.constructor)) {\n      reject(new Error(`Invalid Props`));\n    }\n\n    if (!props.file) {\n      reject(new Error(`Object prop \"file\" is required.`));\n    }\n\n    if (!fs.existsSync(props.file)) {\n      reject(new Error(`Input file \"${props.file}\" does not exists. Please provide valid file.`));\n    } // Load and extract docx file\n\n\n    loadFile(props.file).then(data => {\n      if (data.files['word/document.xml']) {\n        data.files['word/document.xml'].async(\"binarystring\").then(function (content) {\n          // Parse XML data\n          let xmlJsonData = convert.xml2json(content, {\n            compact: true,\n            spaces: 4\n          }); // If the XML data is invalid, resolve empty object\n\n          if (!xmlJsonData) {\n            resolve({});\n          } // Make sure parsed XML file is an object\n\n\n          if (typeof xmlJsonData === 'string') {\n            xmlJsonData = JSON.parse(xmlJsonData);\n          }\n\n          const result = parseTables(xmlJsonData);\n          resolve(result);\n        });\n      } else {\n        resolve({});\n      }\n    }).catch(error => {\n      reject(error);\n    });\n  });\n};","map":{"version":3,"sources":["E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/docx-tables/index.js"],"names":["fs","require","path","JSZip","convert","loadFile","file","Promise","resolve","reject","readFile","err","data","loadAsync","then","zip","catch","error","parseTables","xmlJsonData","tables","wTable","constructor","forEach","wTableItem","result","wTableItemRow","wTableItemRowItem","rowIndex","wTableItemRowColumn","rowObject","wTableItemRowColumnItem","colIndex","wp","wpItem","_text","push","position","row","col","Object","assign","module","exports","props","Error","existsSync","files","async","content","xml2json","compact","spaces","JSON","parse"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst fs = require('fs')\r\nconst path = require('path')\r\nconst JSZip = require('jszip')\r\nconst convert = require('xml-js')\r\n\r\n/**\r\n * Load and Extract given docx file\r\n */\r\nasync function loadFile (file) {\r\n  return new Promise((resolve, reject) => {\r\n    fs.readFile(file, function (err, data) {\r\n      if (err) {\r\n        reject(err)\r\n      }\r\n      JSZip.loadAsync(data).then(function (zip) {\r\n        resolve(zip)\r\n      }).catch((error) => {\r\n        reject(error)\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Main Logic for extracting Table data from XML JSON data\r\n */\r\nfunction parseTables (xmlJsonData) {\r\n  const tables = []\r\n  try {\r\n    let wTable = xmlJsonData['w:document']['w:body']['w:tbl']\r\n    if (wTable) {\r\n      if (wTable.constructor !== [].constructor) {\r\n        wTable = [ wTable ]\r\n      }\r\n      wTable.forEach((wTableItem) => {\r\n        const result = {}\r\n        const wTableItemRow = wTableItem['w:tr']\r\n        wTableItemRow.forEach((wTableItemRowItem, rowIndex) => {\r\n          const wTableItemRowColumn = wTableItemRowItem['w:tc']\r\n          const rowObject = []\r\n          wTableItemRowColumn.forEach((wTableItemRowColumnItem, colIndex) => {\r\n            let wp = wTableItemRowColumnItem['w:p']\r\n            if (wp) {\r\n              if ( wp.constructor !== [].constructor) {\r\n                wp = [ wp ]\r\n              }\r\n              let data = ''\r\n              wp.forEach((wpItem) => {\r\n                if (wpItem['w:r'] && wpItem['w:r']['w:t'] && wpItem['w:r']['w:t']._text) {\r\n                  data += `${wpItem['w:r']['w:t']._text}\\n`\r\n                }\r\n              })\r\n              //if (data) {\r\n                rowObject.push({\r\n                  position: {\r\n                    row: rowIndex,\r\n                    col: colIndex\r\n                  },\r\n                  data \r\n                })\r\n              //}\r\n            }\r\n            // console.log('++++++++++++++++++')\r\n          })\r\n          //if (rowObject && rowObject.constructor === [].constructor && rowObject.length > 0) {\r\n            result[`${rowIndex}`] = Object.assign([], rowObject)\r\n          //}\r\n          // console.log('==========================')\r\n        })\r\n        tables.push(result) \r\n      })\r\n    }\r\n  } catch (error) {\r\n    return error\r\n  }\r\n\r\n  return tables\r\n}\r\n\r\nmodule.exports = function (props) {\r\n  return new Promise((resolve, reject) => {\r\n    if (!(props && props.constructor === {}.constructor)) {\r\n      reject(new Error(`Invalid Props`))\r\n    }\r\n    if (!props.file) {\r\n      reject(new Error(`Object prop \"file\" is required.`))\r\n    }\r\n    if (!fs.existsSync(props.file)) {\r\n      reject(new Error(`Input file \"${props.file}\" does not exists. Please provide valid file.`))\r\n    }\r\n    // Load and extract docx file\r\n    loadFile(props.file).then((data) => {\r\n      if (data.files['word/document.xml']) {\r\n        data.files['word/document.xml'].async(\"binarystring\").then(function (content) {\r\n          // Parse XML data\r\n          let xmlJsonData = convert.xml2json(content, {compact: true, spaces: 4})\r\n          // If the XML data is invalid, resolve empty object\r\n          if (!xmlJsonData) {\r\n            resolve({})\r\n          }\r\n          // Make sure parsed XML file is an object\r\n          if (typeof xmlJsonData === 'string') {\r\n            xmlJsonData = JSON.parse(xmlJsonData)\r\n          }\r\n          \r\n          const result = parseTables(xmlJsonData)\r\n          resolve(result)\r\n        })\r\n      } else {\r\n        resolve({})\r\n      }\r\n    }).catch((error) => {\r\n      reject(error)\r\n    })\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"script"}