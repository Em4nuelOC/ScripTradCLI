{"ast":null,"code":"import _asyncToGenerator from \"E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nconst kAdapter = Symbol('adapter');\n\nclass FileSystemHandle {\n  /** @type {FileSystemHandle} */\n  [kAdapter];\n  /** @type {string} */\n\n  name;\n  /** @type {('file'|'directory')} */\n\n  kind;\n  /** @param {FileSystemHandle & {writable}} adapter */\n\n  constructor(adapter) {\n    this.kind = adapter.kind;\n    this.name = adapter.name;\n    this[kAdapter] = adapter;\n  }\n\n  queryPermission({\n    mode = 'read'\n  } = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = _this[kAdapter];\n\n      if (handle.queryPermission) {\n        return handle.queryPermission({\n          mode\n        });\n      }\n\n      if (mode === 'read') {\n        return 'granted';\n      } else if (mode === 'readwrite') {\n        return handle.writable ? 'granted' : 'denied';\n      } else {\n        throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);\n      }\n    })();\n  }\n\n  requestPermission({\n    mode = 'read'\n  } = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = _this2[kAdapter];\n\n      if (handle.requestPermission) {\n        return handle.requestPermission({\n          mode\n        });\n      }\n\n      if (mode === 'read') {\n        return 'granted';\n      } else if (mode === 'readwrite') {\n        return handle.writable ? 'granted' : 'denied';\n      } else {\n        throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);\n      }\n    })();\n  }\n  /**\n   * Attempts to remove the entry represented by handle from the underlying file system.\n   *\n   * @param {object} options\n   * @param {boolean} [options.recursive=false]\n   */\n\n\n  remove(options = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3[kAdapter].remove(options);\n    })();\n  }\n  /**\n   * @param {FileSystemHandle} other\n   */\n\n\n  isSameEntry(other) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this4 === other) return true;\n      if (!other || typeof other !== 'object' || _this4.kind !== other.kind || !other[kAdapter]) return false;\n      return _this4[kAdapter].isSameEntry(other[kAdapter]);\n    })();\n  }\n\n}\n\nObject.defineProperty(FileSystemHandle.prototype, Symbol.toStringTag, {\n  value: 'FileSystemHandle',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nexport default FileSystemHandle;\nexport { FileSystemHandle };","map":{"version":3,"sources":["E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/native-file-system-adapter/src/FileSystemHandle.js"],"names":["kAdapter","Symbol","FileSystemHandle","name","kind","constructor","adapter","queryPermission","mode","handle","writable","TypeError","requestPermission","remove","options","isSameEntry","other","Object","defineProperty","prototype","toStringTag","value","enumerable","configurable"],"mappings":";AAAA,MAAMA,QAAQ,GAAGC,MAAM,CAAC,SAAD,CAAvB;;AAEA,MAAMC,gBAAN,CAAuB;AACrB;AACS,GAARF,QAAQ;AAET;;AACAG,EAAAA,IAAI;AACJ;;AACAC,EAAAA,IAAI;AAEJ;;AACAC,EAAAA,WAAW,CAAEC,OAAF,EAAW;AACpB,SAAKF,IAAL,GAAYE,OAAO,CAACF,IAApB;AACA,SAAKD,IAAL,GAAYG,OAAO,CAACH,IAApB;AACA,SAAKH,QAAL,IAAiBM,OAAjB;AACD;;AAEKC,EAAAA,eAAe,CAAE;AAACC,IAAAA,IAAI,GAAG;AAAR,MAAkB,EAApB,EAAwB;AAAA;;AAAA;AAC3C,YAAMC,MAAM,GAAG,KAAI,CAACT,QAAD,CAAnB;;AAEA,UAAIS,MAAM,CAACF,eAAX,EAA4B;AAC1B,eAAOE,MAAM,CAACF,eAAP,CAAuB;AAACC,UAAAA;AAAD,SAAvB,CAAP;AACD;;AAED,UAAIA,IAAI,KAAK,MAAb,EAAqB;AACnB,eAAO,SAAP;AACD,OAFD,MAEO,IAAIA,IAAI,KAAK,WAAb,EAA0B;AAC/B,eAAOC,MAAM,CAACC,QAAP,GAAkB,SAAlB,GAA8B,QAArC;AACD,OAFM,MAEA;AACL,cAAM,IAAIC,SAAJ,CAAe,QAAOH,IAAK,gCAA3B,CAAN;AACD;AAb0C;AAc5C;;AAEKI,EAAAA,iBAAiB,CAAE;AAACJ,IAAAA,IAAI,GAAG;AAAR,MAAkB,EAApB,EAAwB;AAAA;;AAAA;AAC7C,YAAMC,MAAM,GAAG,MAAI,CAACT,QAAD,CAAnB;;AACA,UAAIS,MAAM,CAACG,iBAAX,EAA8B;AAC5B,eAAOH,MAAM,CAACG,iBAAP,CAAyB;AAACJ,UAAAA;AAAD,SAAzB,CAAP;AACD;;AAED,UAAIA,IAAI,KAAK,MAAb,EAAqB;AACnB,eAAO,SAAP;AACD,OAFD,MAEO,IAAIA,IAAI,KAAK,WAAb,EAA0B;AAC/B,eAAOC,MAAM,CAACC,QAAP,GAAkB,SAAlB,GAA8B,QAArC;AACD,OAFM,MAEA;AACL,cAAM,IAAIC,SAAJ,CAAe,QAAOH,IAAK,gCAA3B,CAAN;AACD;AAZ4C;AAa9C;AAED;AACF;AACA;AACA;AACA;AACA;;;AACQK,EAAAA,MAAM,CAAEC,OAAO,GAAG,EAAZ,EAAgB;AAAA;;AAAA;AAC1B,YAAM,MAAI,CAACd,QAAD,CAAJ,CAAea,MAAf,CAAsBC,OAAtB,CAAN;AAD0B;AAE3B;AAED;AACF;AACA;;;AACQC,EAAAA,WAAW,CAAEC,KAAF,EAAS;AAAA;;AAAA;AACxB,UAAI,MAAI,KAAKA,KAAb,EAAoB,OAAO,IAAP;AACpB,UACG,CAACA,KAAF,IACC,OAAOA,KAAP,KAAiB,QADlB,IAEC,MAAI,CAACZ,IAAL,KAAcY,KAAK,CAACZ,IAFrB,IAGC,CAACY,KAAK,CAAChB,QAAD,CAJT,EAKE,OAAO,KAAP;AACF,aAAO,MAAI,CAACA,QAAD,CAAJ,CAAee,WAAf,CAA2BC,KAAK,CAAChB,QAAD,CAAhC,CAAP;AARwB;AASzB;;AArEoB;;AAwEvBiB,MAAM,CAACC,cAAP,CAAsBhB,gBAAgB,CAACiB,SAAvC,EAAkDlB,MAAM,CAACmB,WAAzD,EAAsE;AACpEC,EAAAA,KAAK,EAAE,kBAD6D;AAEpEX,EAAAA,QAAQ,EAAE,KAF0D;AAGpEY,EAAAA,UAAU,EAAE,KAHwD;AAIpEC,EAAAA,YAAY,EAAE;AAJsD,CAAtE;AAOA,eAAerB,gBAAf;AACA,SAASA,gBAAT","sourcesContent":["const kAdapter = Symbol('adapter')\n\nclass FileSystemHandle {\n  /** @type {FileSystemHandle} */\n  [kAdapter]\n\n  /** @type {string} */\n  name\n  /** @type {('file'|'directory')} */\n  kind\n\n  /** @param {FileSystemHandle & {writable}} adapter */\n  constructor (adapter) {\n    this.kind = adapter.kind\n    this.name = adapter.name\n    this[kAdapter] = adapter\n  }\n\n  async queryPermission ({mode = 'read'} = {}) {\n    const handle = this[kAdapter]\n\n    if (handle.queryPermission) {\n      return handle.queryPermission({mode})\n    }\n\n    if (mode === 'read') {\n      return 'granted'\n    } else if (mode === 'readwrite') {\n      return handle.writable ? 'granted' : 'denied'\n    } else {\n      throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`)\n    }\n  }\n\n  async requestPermission ({mode = 'read'} = {}) {\n    const handle = this[kAdapter]\n    if (handle.requestPermission) {\n      return handle.requestPermission({mode})\n    }\n\n    if (mode === 'read') {\n      return 'granted'\n    } else if (mode === 'readwrite') {\n      return handle.writable ? 'granted' : 'denied'\n    } else {\n      throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`)\n    }\n  }\n\n  /**\n   * Attempts to remove the entry represented by handle from the underlying file system.\n   *\n   * @param {object} options\n   * @param {boolean} [options.recursive=false]\n   */\n  async remove (options = {}) {\n    await this[kAdapter].remove(options)\n  }\n\n  /**\n   * @param {FileSystemHandle} other\n   */\n  async isSameEntry (other) {\n    if (this === other) return true\n    if (\n      (!other) ||\n      (typeof other !== 'object') ||\n      (this.kind !== other.kind) ||\n      (!other[kAdapter])\n    ) return false\n    return this[kAdapter].isSameEntry(other[kAdapter])\n  }\n}\n\nObject.defineProperty(FileSystemHandle.prototype, Symbol.toStringTag, {\n  value: 'FileSystemHandle',\n  writable: false,\n  enumerable: false,\n  configurable: true\n})\n\nexport default FileSystemHandle\nexport { FileSystemHandle }\n"]},"metadata":{},"sourceType":"module"}