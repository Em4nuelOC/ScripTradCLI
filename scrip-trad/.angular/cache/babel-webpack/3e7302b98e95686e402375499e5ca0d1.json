{"ast":null,"code":"//filter will reemit the data if cb(err,pass) pass is truthy\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\nvar Stream = require('stream').Stream,\n    es = exports,\n    through = require('through'),\n    from = require('from'),\n    duplex = require('duplexer'),\n    map = require('map-stream'),\n    pause = require('pause-stream'),\n    split = require('split'),\n    pipeline = require('stream-combiner'),\n    immediately = global.setImmediate || process.nextTick;\n\nes.Stream = Stream; //re-export Stream from core\n\nes.through = through;\nes.from = from;\nes.duplex = duplex;\nes.map = map;\nes.pause = pause;\nes.split = split;\nes.pipeline = es.connect = es.pipe = pipeline; // merge / concat\n//\n// combine multiple streams into a single stream.\n// will emit end only once\n\nes.concat = //actually this should be called concat\nes.merge = function () {\n  var toMerge = [].slice.call(arguments);\n\n  if (toMerge.length === 1 && toMerge[0] instanceof Array) {\n    toMerge = toMerge[0]; //handle array as arguments object\n  }\n\n  var stream = new Stream();\n  stream.setMaxListeners(0); // allow adding more than 11 streams\n\n  var endCount = 0;\n  stream.writable = stream.readable = true;\n\n  if (toMerge.length) {\n    toMerge.forEach(function (e) {\n      e.pipe(stream, {\n        end: false\n      });\n      var ended = false;\n      e.on('end', function () {\n        if (ended) return;\n        ended = true;\n        endCount++;\n        if (endCount == toMerge.length) stream.emit('end');\n      });\n    });\n  } else {\n    process.nextTick(function () {\n      stream.emit('end');\n    });\n  }\n\n  stream.write = function (data) {\n    this.emit('data', data);\n  };\n\n  stream.destroy = function () {\n    toMerge.forEach(function (e) {\n      if (e.destroy) e.destroy();\n    });\n  };\n\n  return stream;\n}; // writable stream, collects all events into an array\n// and calls back when 'end' occurs\n// mainly I'm using this to test the other functions\n\n\nes.writeArray = function (done) {\n  if ('function' !== typeof done) throw new Error('function writeArray (done): done must be function');\n  var a = new Stream(),\n      array = [],\n      isDone = false;\n\n  a.write = function (l) {\n    array.push(l);\n  };\n\n  a.end = function () {\n    isDone = true;\n    done(null, array);\n  };\n\n  a.writable = true;\n  a.readable = false;\n\n  a.destroy = function () {\n    a.writable = a.readable = false;\n    if (isDone) return;\n    done(new Error('destroyed before end'), array);\n  };\n\n  return a;\n}; //return a Stream that reads the properties of an object\n//respecting pause() and resume()\n\n\nes.readArray = function (array) {\n  var stream = new Stream(),\n      i = 0,\n      paused = false,\n      ended = false;\n  stream.readable = true;\n  stream.writable = false;\n  if (!Array.isArray(array)) throw new Error('event-stream.read expects an array');\n\n  stream.resume = function () {\n    if (ended) return;\n    paused = false;\n    var l = array.length;\n\n    while (i < l && !paused && !ended) {\n      stream.emit('data', array[i++]);\n    }\n\n    if (i == l && !ended) ended = true, stream.readable = false, stream.emit('end');\n  };\n\n  process.nextTick(stream.resume);\n\n  stream.pause = function () {\n    paused = true;\n  };\n\n  stream.destroy = function () {\n    ended = true;\n    stream.emit('close');\n  };\n\n  return stream;\n}; //\n// readable (asyncFunction)\n// return a stream that calls an async function while the stream is not paused.\n//\n// the function must take: (count, callback) {...\n//\n\n\nes.readable = function (func, continueOnError) {\n  var stream = new Stream(),\n      i = 0,\n      paused = false,\n      ended = false,\n      reading = false;\n  stream.readable = true;\n  stream.writable = false;\n  if ('function' !== typeof func) throw new Error('event-stream.readable expects async function');\n  stream.on('end', function () {\n    ended = true;\n  });\n\n  function get(err, data) {\n    if (err) {\n      stream.emit('error', err);\n      if (!continueOnError) stream.emit('end');\n    } else if (arguments.length > 1) stream.emit('data', data);\n\n    immediately(function () {\n      if (ended || paused || reading) return;\n\n      try {\n        reading = true;\n        func.call(stream, i++, function () {\n          reading = false;\n          get.apply(null, arguments);\n        });\n      } catch (err) {\n        stream.emit('error', err);\n      }\n    });\n  }\n\n  stream.resume = function () {\n    paused = false;\n    get();\n  };\n\n  process.nextTick(get);\n\n  stream.pause = function () {\n    paused = true;\n  };\n\n  stream.destroy = function () {\n    stream.emit('end');\n    stream.emit('close');\n    ended = true;\n  };\n\n  return stream;\n}; //\n// map sync\n//\n\n\nes.mapSync = function (sync) {\n  return es.through(function write(data) {\n    var mappedData;\n\n    try {\n      mappedData = sync(data);\n    } catch (err) {\n      return this.emit('error', err);\n    }\n\n    if (mappedData !== undefined) this.emit('data', mappedData);\n  });\n}; //\n// log just print out what is coming through the stream, for debugging\n//\n\n\nes.log = function (name) {\n  return es.through(function (data) {\n    var args = [].slice.call(arguments);\n    if (name) console.error(name, data);else console.error(data);\n    this.emit('data', data);\n  });\n}; //\n// child -- pipe through a child process\n//\n\n\nes.child = function (child) {\n  return es.duplex(child.stdin, child.stdout);\n}; //\n// parse\n//\n// must be used after es.split() to ensure that each chunk represents a line\n// source.pipe(es.split()).pipe(es.parse())\n\n\nes.parse = function (options) {\n  var emitError = !!(options ? options.error : false);\n  return es.through(function (data) {\n    var obj;\n\n    try {\n      if (data) //ignore empty lines\n        obj = JSON.parse(data.toString());\n    } catch (err) {\n      if (emitError) return this.emit('error', err);\n      return console.error(err, 'attempting to parse:', data);\n    } //ignore lines that where only whitespace.\n\n\n    if (obj !== undefined) this.emit('data', obj);\n  });\n}; //\n// stringify\n//\n\n\nes.stringify = function () {\n  var Buffer = require('buffer').Buffer;\n\n  return es.mapSync(function (e) {\n    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\\n';\n  });\n}; //\n// replace a string within a stream.\n//\n// warn: just concatenates the string and then does str.split().join().\n// probably not optimal.\n// for smallish responses, who cares?\n// I need this for shadow-npm so it's only relatively small json files.\n\n\nes.replace = function (from, to) {\n  return es.pipeline(es.split(from), es.join(to));\n}; //\n// join chunks with a joiner. just like Array#join\n// also accepts a callback that is passed the chunks appended together\n// this is still supported for legacy reasons.\n//\n\n\nes.join = function (str) {\n  //legacy api\n  if ('function' === typeof str) return es.wait(str);\n  var first = true;\n  return es.through(function (data) {\n    if (!first) this.emit('data', str);\n    first = false;\n    this.emit('data', data);\n    return true;\n  });\n}; //\n// wait. callback when 'end' is emitted, with all chunks appended as string.\n//\n\n\nes.wait = function (callback) {\n  var arr = [];\n  return es.through(function (data) {\n    arr.push(data);\n  }, function () {\n    var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr) : arr.join('');\n    this.emit('data', body);\n    this.emit('end');\n    if (callback) callback(null, body);\n  });\n};\n\nes.pipeable = function () {\n  throw new Error('[EVENT-STREAM] es.pipeable is deprecated');\n};","map":{"version":3,"sources":["C:/Users/CND12816RD/Desktop/Sabrina/github/Scriptrad/ScripTradCLI/scrip-trad/node_modules/event-stream/index.js"],"names":["Stream","require","es","exports","through","from","duplex","map","pause","split","pipeline","immediately","global","setImmediate","process","nextTick","connect","pipe","concat","merge","toMerge","slice","call","arguments","length","Array","stream","setMaxListeners","endCount","writable","readable","forEach","e","end","ended","on","emit","write","data","destroy","writeArray","done","Error","a","array","isDone","l","push","readArray","i","paused","isArray","resume","func","continueOnError","reading","get","err","apply","mapSync","sync","mappedData","undefined","log","name","args","console","error","child","stdin","stdout","parse","options","emitError","obj","JSON","toString","stringify","Buffer","isBuffer","replace","to","join","str","wait","first","callback","arr","body","pipeable"],"mappings":"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","sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\nvar Stream = require('stream').Stream\n  , es = exports\n  , through = require('through')\n  , from = require('from')\n  , duplex = require('duplexer')\n  , map = require('map-stream')\n  , pause = require('pause-stream')\n  , split = require('split')\n  , pipeline = require('stream-combiner')\n  , immediately = global.setImmediate || process.nextTick;\n\nes.Stream = Stream //re-export Stream from core\nes.through = through\nes.from = from\nes.duplex = duplex\nes.map = map\nes.pause = pause\nes.split = split\nes.pipeline = es.connect = es.pipe = pipeline\n// merge / concat\n//\n// combine multiple streams into a single stream.\n// will emit end only once\n\nes.concat = //actually this should be called concat\nes.merge = function (/*streams...*/) {\n  var toMerge = [].slice.call(arguments)\n  if (toMerge.length === 1 && (toMerge[0] instanceof Array)) {\n    toMerge = toMerge[0] //handle array as arguments object\n  }\n  var stream = new Stream()\n  stream.setMaxListeners(0) // allow adding more than 11 streams\n  var endCount = 0\n  stream.writable = stream.readable = true\n\n  if (toMerge.length) {\n    toMerge.forEach(function (e) {\n      e.pipe(stream, {end: false})\n      var ended = false\n      e.on('end', function () {\n        if(ended) return\n        ended = true\n        endCount ++\n        if(endCount == toMerge.length)\n          stream.emit('end')\n      })\n    })\n  } else {\n    process.nextTick(function () {\n      stream.emit('end')\n    })\n  }\n  \n  stream.write = function (data) {\n    this.emit('data', data)\n  }\n  stream.destroy = function () {\n    toMerge.forEach(function (e) {\n      if(e.destroy) e.destroy()\n    })\n  }\n  return stream\n}\n\n\n// writable stream, collects all events into an array\n// and calls back when 'end' occurs\n// mainly I'm using this to test the other functions\n\nes.writeArray = function (done) {\n  if ('function' !== typeof done)\n    throw new Error('function writeArray (done): done must be function')\n\n  var a = new Stream ()\n    , array = [], isDone = false\n  a.write = function (l) {\n    array.push(l)\n  }\n  a.end = function () {\n    isDone = true\n    done(null, array)\n  }\n  a.writable = true\n  a.readable = false\n  a.destroy = function () {\n    a.writable = a.readable = false\n    if(isDone) return\n    done(new Error('destroyed before end'), array)\n  }\n  return a\n}\n\n//return a Stream that reads the properties of an object\n//respecting pause() and resume()\n\nes.readArray = function (array) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n\n  stream.readable = true\n  stream.writable = false\n\n  if(!Array.isArray(array))\n    throw new Error('event-stream.read expects an array')\n\n  stream.resume = function () {\n    if(ended) return\n    paused = false\n    var l = array.length\n    while(i < l && !paused && !ended) {\n      stream.emit('data', array[i++])\n    }\n    if(i == l && !ended)\n      ended = true, stream.readable = false, stream.emit('end')\n  }\n  process.nextTick(stream.resume)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    ended = true\n    stream.emit('close')\n  }\n  return stream\n}\n\n//\n// readable (asyncFunction)\n// return a stream that calls an async function while the stream is not paused.\n//\n// the function must take: (count, callback) {...\n//\n\nes.readable =\nfunction (func, continueOnError) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n    , reading = false\n\n  stream.readable = true\n  stream.writable = false\n\n  if('function' !== typeof func)\n    throw new Error('event-stream.readable expects async function')\n\n  stream.on('end', function () { ended = true })\n\n  function get (err, data) {\n\n    if(err) {\n      stream.emit('error', err)\n      if(!continueOnError) stream.emit('end')\n    } else if (arguments.length > 1)\n      stream.emit('data', data)\n\n    immediately(function () {\n      if(ended || paused || reading) return\n      try {\n        reading = true\n        func.call(stream, i++, function () {\n          reading = false\n          get.apply(null, arguments)\n        })\n      } catch (err) {\n        stream.emit('error', err)\n      }\n    })\n  }\n  stream.resume = function () {\n    paused = false\n    get()\n  }\n  process.nextTick(get)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    stream.emit('end')\n    stream.emit('close')\n    ended = true\n  }\n  return stream\n}\n\n\n//\n// map sync\n//\n\nes.mapSync = function (sync) {\n  return es.through(function write(data) {\n    var mappedData\n    try {\n      mappedData = sync(data)\n    } catch (err) {\n      return this.emit('error', err)\n    }\n    if (mappedData !== undefined)\n      this.emit('data', mappedData)\n  })\n}\n\n//\n// log just print out what is coming through the stream, for debugging\n//\n\nes.log = function (name) {\n  return es.through(function (data) {\n    var args = [].slice.call(arguments)\n    if(name) console.error(name, data)\n    else     console.error(data)\n    this.emit('data', data)\n  })\n}\n\n\n//\n// child -- pipe through a child process\n//\n\nes.child = function (child) {\n\n  return es.duplex(child.stdin, child.stdout)\n\n}\n\n//\n// parse\n//\n// must be used after es.split() to ensure that each chunk represents a line\n// source.pipe(es.split()).pipe(es.parse())\n\nes.parse = function (options) {\n  var emitError = !!(options ? options.error : false)\n  return es.through(function (data) {\n    var obj\n    try {\n      if(data) //ignore empty lines\n        obj = JSON.parse(data.toString())\n    } catch (err) {\n      if (emitError)\n        return this.emit('error', err)\n      return console.error(err, 'attempting to parse:', data)\n    }\n    //ignore lines that where only whitespace.\n    if(obj !== undefined)\n      this.emit('data', obj)\n  })\n}\n//\n// stringify\n//\n\nes.stringify = function () {\n  var Buffer = require('buffer').Buffer\n  return es.mapSync(function (e){\n    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\\n'\n  })\n}\n\n//\n// replace a string within a stream.\n//\n// warn: just concatenates the string and then does str.split().join().\n// probably not optimal.\n// for smallish responses, who cares?\n// I need this for shadow-npm so it's only relatively small json files.\n\nes.replace = function (from, to) {\n  return es.pipeline(es.split(from), es.join(to))\n}\n\n//\n// join chunks with a joiner. just like Array#join\n// also accepts a callback that is passed the chunks appended together\n// this is still supported for legacy reasons.\n//\n\nes.join = function (str) {\n\n  //legacy api\n  if('function' === typeof str)\n    return es.wait(str)\n\n  var first = true\n  return es.through(function (data) {\n    if(!first)\n      this.emit('data', str)\n    first = false\n    this.emit('data', data)\n    return true\n  })\n}\n\n\n//\n// wait. callback when 'end' is emitted, with all chunks appended as string.\n//\n\nes.wait = function (callback) {\n  var arr = []\n  return es.through(function (data) { arr.push(data) },\n    function () {\n      var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr)\n        : arr.join('')\n      this.emit('data', body)\n      this.emit('end')\n      if(callback) callback(null, body)\n    })\n}\n\nes.pipeable = function () {\n  throw new Error('[EVENT-STREAM] es.pipeable is deprecated')\n}\n"]},"metadata":{},"sourceType":"script"}