{"ast":null,"code":"import _asyncToGenerator from \"E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _awaitAsyncGenerator from \"E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\n\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\n\nimport FileSystemHandle from './FileSystemHandle.js';\nconst kAdapter = Symbol('adapter');\n\nclass FileSystemDirectoryHandle extends FileSystemHandle {\n  /** @type {FileSystemDirectoryHandle} */\n  [kAdapter];\n\n  constructor(adapter) {\n    super(adapter);\n    this[kAdapter] = adapter;\n  }\n  /**\n   * @param {string} name Name of the directory\n   * @param {object} [options]\n   * @param {boolean} [options.create] create the directory if don't exist\n   * @returns {Promise<FileSystemDirectoryHandle>}\n   */\n\n\n  getDirectoryHandle(name, options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (name === '') throw new TypeError(`Name can't be an empty string.`);\n      if (name === '.' || name === '..' || name.includes('/')) throw new TypeError(`Name contains invalid characters.`);\n      options.create = !!options.create;\n      return new FileSystemDirectoryHandle(yield _this5[kAdapter].getDirectoryHandle(name, options));\n    })();\n  }\n  /** @returns {AsyncGenerator<[string, FileSystemHandle | FileSystemDirectoryHandle]>} */\n\n\n  entries() {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const {\n        FileSystemFileHandle\n      } = yield _awaitAsyncGenerator(import('./FileSystemFileHandle.js'));\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(_this[kAdapter].entries()), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n          const [_, entry] = _step.value;\n          yield [entry.name, entry.kind === 'file' ? new FileSystemFileHandle(entry) : new FileSystemDirectoryHandle(entry)];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n  /** @deprecated use .entries() instead */\n\n\n  getEntries() {\n    var _this2 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const {\n        FileSystemFileHandle\n      } = yield _awaitAsyncGenerator(import('./FileSystemFileHandle.js'));\n      console.warn('deprecated, use .entries() instead');\n      var _iteratorAbruptCompletion2 = false;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(_this2[kAdapter].entries()), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {\n          let entry = _step2.value;\n          yield entry.kind === 'file' ? new FileSystemFileHandle(entry) : new FileSystemDirectoryHandle(entry);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * @param {string} name Name of the file\n   * @param {object} [options]\n   * @param {boolean} [options.create] create the file if don't exist\n   */\n\n\n  getFileHandle(name, options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        FileSystemFileHandle\n      } = yield import('./FileSystemFileHandle.js');\n      if (name === '') throw new TypeError(`Name can't be an empty string.`);\n      if (name === '.' || name === '..' || name.includes('/')) throw new TypeError(`Name contains invalid characters.`);\n      options.create = !!options.create;\n      return new FileSystemFileHandle(yield _this6[kAdapter].getFileHandle(name, options));\n    })();\n  }\n  /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   */\n\n\n  removeEntry(name, options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (name === '') throw new TypeError(`Name can't be an empty string.`);\n      if (name === '.' || name === '..' || name.includes('/')) throw new TypeError(`Name contains invalid characters.`);\n      options.recursive = !!options.recursive; // cuz node's fs.rm require boolean\n\n      return _this7[kAdapter].removeEntry(name, options);\n    })();\n  } // TODO: jsdoc\n\n\n  resolve(possibleDescendant) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (yield possibleDescendant.isSameEntry(_this8)) {\n        return [];\n      }\n\n      const openSet = [{\n        handle: _this8,\n        path: []\n      }];\n\n      while (openSet.length) {\n        let {\n          handle: current,\n          path\n        } = openSet.pop();\n        var _iteratorAbruptCompletion3 = false;\n        var _didIteratorError3 = false;\n\n        var _iteratorError3;\n\n        try {\n          for (var _iterator3 = _asyncIterator(current.values()), _step3; _iteratorAbruptCompletion3 = !(_step3 = yield _iterator3.next()).done; _iteratorAbruptCompletion3 = false) {\n            const entry = _step3.value;\n\n            if (yield entry.isSameEntry(possibleDescendant)) {\n              return [...path, entry.name];\n            }\n\n            if (entry.kind === 'directory') {\n              openSet.push({\n                handle: entry,\n                path: [...path, entry.name]\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion3 && _iterator3.return != null) {\n              yield _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      return null;\n    })();\n  }\n\n  keys() {\n    var _this3 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorAbruptCompletion4 = false;\n      var _didIteratorError4 = false;\n\n      var _iteratorError4;\n\n      try {\n        for (var _iterator4 = _asyncIterator(_this3[kAdapter].entries()), _step4; _iteratorAbruptCompletion4 = !(_step4 = yield _awaitAsyncGenerator(_iterator4.next())).done; _iteratorAbruptCompletion4 = false) {\n          const [name] = _step4.value;\n          yield name;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion4 && _iterator4.return != null) {\n            yield _awaitAsyncGenerator(_iterator4.return());\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    })();\n  }\n\n  values() {\n    var _this4 = this;\n\n    return _wrapAsyncGenerator(function* () {\n      var _iteratorAbruptCompletion5 = false;\n      var _didIteratorError5 = false;\n\n      var _iteratorError5;\n\n      try {\n        for (var _iterator5 = _asyncIterator(_this4), _step5; _iteratorAbruptCompletion5 = !(_step5 = yield _awaitAsyncGenerator(_iterator5.next())).done; _iteratorAbruptCompletion5 = false) {\n          const [_, entry] = _step5.value;\n          yield entry;\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion5 && _iterator5.return != null) {\n            yield _awaitAsyncGenerator(_iterator5.return());\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    })();\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.entries();\n  }\n\n}\n\nObject.defineProperty(FileSystemDirectoryHandle.prototype, Symbol.toStringTag, {\n  value: 'FileSystemDirectoryHandle',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nObject.defineProperties(FileSystemDirectoryHandle.prototype, {\n  getDirectoryHandle: {\n    enumerable: true\n  },\n  entries: {\n    enumerable: true\n  },\n  getFileHandle: {\n    enumerable: true\n  },\n  removeEntry: {\n    enumerable: true\n  }\n});\nexport default FileSystemDirectoryHandle;\nexport { FileSystemDirectoryHandle };","map":{"version":3,"sources":["E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/native-file-system-adapter/src/FileSystemDirectoryHandle.js"],"names":["FileSystemHandle","kAdapter","Symbol","FileSystemDirectoryHandle","constructor","adapter","getDirectoryHandle","name","options","TypeError","includes","create","entries","FileSystemFileHandle","_","entry","kind","getEntries","console","warn","getFileHandle","removeEntry","recursive","resolve","possibleDescendant","isSameEntry","openSet","handle","path","length","current","pop","values","push","keys","asyncIterator","Object","defineProperty","prototype","toStringTag","value","writable","enumerable","configurable","defineProperties"],"mappings":"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","sourcesContent":["import FileSystemHandle from './FileSystemHandle.js'\n\nconst kAdapter = Symbol('adapter')\n\nclass FileSystemDirectoryHandle extends FileSystemHandle {\n  /** @type {FileSystemDirectoryHandle} */\n  [kAdapter]\n\n  constructor (adapter) {\n    super(adapter)\n    this[kAdapter] = adapter\n  }\n\n  /**\n   * @param {string} name Name of the directory\n   * @param {object} [options]\n   * @param {boolean} [options.create] create the directory if don't exist\n   * @returns {Promise<FileSystemDirectoryHandle>}\n   */\n  async getDirectoryHandle (name, options = {}) {\n    if (name === '') throw new TypeError(`Name can't be an empty string.`)\n    if (name === '.' || name === '..' || name.includes('/')) throw new TypeError(`Name contains invalid characters.`)\n    options.create = !!options.create\n    return new FileSystemDirectoryHandle(await this[kAdapter].getDirectoryHandle(name, options))\n  }\n\n  /** @returns {AsyncGenerator<[string, FileSystemHandle | FileSystemDirectoryHandle]>} */\n  async * entries () {\n    const {FileSystemFileHandle} = await import('./FileSystemFileHandle.js')\n\n    for await (const [_, entry] of this[kAdapter].entries())\n      yield [entry.name, entry.kind === 'file' ? new FileSystemFileHandle(entry) : new FileSystemDirectoryHandle(entry)]\n  }\n\n  /** @deprecated use .entries() instead */\n  async * getEntries() {\n    const {FileSystemFileHandle} = await import('./FileSystemFileHandle.js')\n    console.warn('deprecated, use .entries() instead')\n    for await (let entry of this[kAdapter].entries())\n      yield entry.kind === 'file' ? new FileSystemFileHandle(entry) : new FileSystemDirectoryHandle(entry)\n  }\n\n  /**\n   * @param {string} name Name of the file\n   * @param {object} [options]\n   * @param {boolean} [options.create] create the file if don't exist\n   */\n  async getFileHandle (name, options = {}) {\n    const {FileSystemFileHandle} = await import('./FileSystemFileHandle.js')\n    if (name === '') throw new TypeError(`Name can't be an empty string.`)\n    if (name === '.' || name === '..' || name.includes('/')) throw new TypeError(`Name contains invalid characters.`)\n    options.create = !!options.create\n    return new FileSystemFileHandle(await this[kAdapter].getFileHandle(name, options))\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   */\n  async removeEntry (name, options = {}) {\n    if (name === '') throw new TypeError(`Name can't be an empty string.`)\n    if (name === '.' || name === '..' || name.includes('/')) throw new TypeError(`Name contains invalid characters.`)\n    options.recursive = !!options.recursive // cuz node's fs.rm require boolean\n    return this[kAdapter].removeEntry(name, options)\n  }\n\n  // TODO: jsdoc\n  async resolve (possibleDescendant) {\n    if (await possibleDescendant.isSameEntry(this)) {\n      return []\n    }\n\n    const openSet = [{ handle: this, path: [] }]\n\n    while (openSet.length) {\n      let { handle: current, path } = openSet.pop()\n      for await (const entry of current.values()) {\n        if (await entry.isSameEntry(possibleDescendant)) {\n          return [...path, entry.name]\n        }\n        if (entry.kind === 'directory') {\n          openSet.push({ handle: entry, path: [...path, entry.name] })\n        }\n      }\n    }\n\n    return null\n  }\n\n  async * keys () {\n    for await (const [name] of this[kAdapter].entries())\n      yield name\n  }\n\n  async * values () {\n    for await (const [_, entry] of this)\n      yield entry\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.entries()\n  }\n}\n\nObject.defineProperty(FileSystemDirectoryHandle.prototype, Symbol.toStringTag, {\n\tvalue: 'FileSystemDirectoryHandle',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n})\n\nObject.defineProperties(FileSystemDirectoryHandle.prototype, {\n\tgetDirectoryHandle: { enumerable: true },\n\tentries: { enumerable: true },\n\tgetFileHandle: { enumerable: true },\n\tremoveEntry: { enumerable: true }\n})\n\nexport default FileSystemDirectoryHandle\nexport { FileSystemDirectoryHandle }\n"]},"metadata":{},"sourceType":"module"}