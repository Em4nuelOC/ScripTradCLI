{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/CND12816RD/Desktop/Sabrina/github/Scriptrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst fs = require('fs');\n\nconst StreamZip = require('node-stream-zip');\n\nconst XLSX = require('xlsx');\n\nconst pdf = require('pdf-parse');\n\nvar WordExtractor = require('word-extractor'); // extract text from office books as doc and docx\n\n\nextract = filePath => {\n  return new Promise((resolve, reject) => {\n    open(filePath).then((res, err) => {\n      if (err) {\n        reject(err);\n      }\n\n      let body = '';\n      let components = res.toString().split('<w:t');\n\n      for (let i = 0; i < components.length; i++) {\n        let tags = components[i].split('>');\n        let content = tags[1].replace(/<.*$/, '');\n        body += content;\n      }\n\n      resolve(body);\n    });\n  });\n}; // stream\n\n\nopen = filePath => {\n  return new Promise((resolve, reject) => {\n    const zip = new StreamZip({\n      file: filePath,\n      storeEntries: true\n    });\n    zip.on('ready', () => {\n      let chunks = [];\n      let content = '';\n      zip.stream('word/document.xml', (err, stream) => {\n        if (err) {\n          reject(err);\n        }\n\n        stream.on('data', chunk => {\n          chunks.push(chunk);\n        });\n        stream.on('end', () => {\n          content = Buffer.concat(chunks);\n          zip.close();\n          resolve(content.toString());\n        });\n      });\n    });\n  });\n}; // get the file extension based on the file path\n\n\ngetFileExtension = filename => {\n  if (filename.length == 0) return '';\n  let dot = filename.lastIndexOf('.');\n  if (dot == -1) return '';\n  const extension = filename.substr(dot, filename.length);\n  return extension;\n}; // read the file and extract text\n\n\nexports.getText = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (filePath) {\n    let fileContent = '';\n    let data = fs.readFileSync(filePath);\n    const fileExtension = getFileExtension(filePath);\n\n    switch (fileExtension) {\n      // read pdf\n      case '.pdf':\n        fileContent = yield (yield pdf(data)).text;\n        break;\n      // read docs\n\n      case '.docx':\n        fileContent = yield extract(filePath);\n        break;\n\n      case '.doc':\n        var extractor = new WordExtractor();\n        var extracted = yield extractor.extract(filePath);\n        fileContent = extracted.getBody();\n        break;\n      // read excel books\n\n      case '.xlsx':\n      case '.xls':\n        let result = {};\n        data = new Uint8Array(data);\n        let workbook = XLSX.read(data, {\n          type: 'array'\n        });\n        workbook.SheetNames.forEach(function (sheetName) {\n          let roa = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], {\n            header: 1\n          });\n          if (roa.length) result[sheetName] = roa;\n        });\n        fileContent = JSON.stringify(result);\n        break;\n      // read text and csv\n\n      case '.txt':\n      case '.csv':\n        fileContent = data.toString();\n        break;\n      // default case\n\n      default:\n        throw new Error('unknown extension found!');\n    } // console.log(`This is file content ==> ${fileContent}`);\n\n\n    return fileContent;\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["C:/Users/CND12816RD/Desktop/Sabrina/github/Scriptrad/ScripTradCLI/scrip-trad/node_modules/any-text/index.js"],"names":["fs","require","StreamZip","XLSX","pdf","WordExtractor","extract","filePath","Promise","resolve","reject","open","then","res","err","body","components","toString","split","i","length","tags","content","replace","zip","file","storeEntries","on","chunks","stream","chunk","push","Buffer","concat","close","getFileExtension","filename","dot","lastIndexOf","extension","substr","exports","getText","fileContent","data","readFileSync","fileExtension","text","extractor","extracted","getBody","result","Uint8Array","workbook","read","type","SheetNames","forEach","sheetName","roa","utils","sheet_to_json","Sheets","header","JSON","stringify","Error"],"mappings":"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","sourcesContent":["const fs = require('fs');\nconst StreamZip = require('node-stream-zip');\nconst XLSX = require('xlsx');\nconst pdf = require('pdf-parse');\nvar WordExtractor = require('word-extractor');\n\n// extract text from office books as doc and docx\nextract = (filePath) => {\n  return new Promise((resolve, reject) => {\n    open(filePath).then((res, err) => {\n      if (err) {\n        reject(err);\n      }\n      let body = '';\n      let components = res.toString().split('<w:t');\n      for (let i = 0; i < components.length; i++) {\n        let tags = components[i].split('>');\n        let content = tags[1].replace(/<.*$/, '');\n        body += content;\n      }\n      resolve(body);\n    });\n  });\n};\n\n// stream\nopen = (filePath) => {\n  return new Promise((resolve, reject) => {\n    const zip = new StreamZip({\n      file: filePath,\n      storeEntries: true,\n    });\n    zip.on('ready', () => {\n      let chunks = [];\n      let content = '';\n      zip.stream('word/document.xml', (err, stream) => {\n        if (err) {\n          reject(err);\n        }\n        stream.on('data', (chunk) => {\n          chunks.push(chunk);\n        });\n        stream.on('end', () => {\n          content = Buffer.concat(chunks);\n          zip.close();\n          resolve(content.toString());\n        });\n      });\n    });\n  });\n};\n\n// get the file extension based on the file path\ngetFileExtension = (filename) => {\n  if (filename.length == 0) return '';\n  let dot = filename.lastIndexOf('.');\n  if (dot == -1) return '';\n  const extension = filename.substr(dot, filename.length);\n  return extension;\n};\n\n// read the file and extract text\nexports.getText = async (filePath) => {\n  let fileContent = '';\n\n  let data = fs.readFileSync(filePath);\n  const fileExtension = getFileExtension(filePath);\n\n  switch (fileExtension) {\n    // read pdf\n    case '.pdf':\n      fileContent = await (await pdf(data)).text;\n      break;\n\n    // read docs\n\n    case '.docx':\n      fileContent = await extract(filePath);\n      break;\n\n    case '.doc':\n      var extractor = new WordExtractor();\n      var extracted = await extractor.extract(filePath);\n      fileContent = extracted.getBody();\n      break;\n\n    // read excel books\n    case '.xlsx':\n    case '.xls':\n      let result = {};\n      data = new Uint8Array(data);\n      let workbook = XLSX.read(data, {\n        type: 'array',\n      });\n      workbook.SheetNames.forEach(function (sheetName) {\n        let roa = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], {\n          header: 1,\n        });\n        if (roa.length) result[sheetName] = roa;\n      });\n      fileContent = JSON.stringify(result);\n      break;\n\n    // read text and csv\n    case '.txt':\n    case '.csv':\n      fileContent = data.toString();\n      break;\n\n    // default case\n    default:\n      throw new Error('unknown extension found!');\n  }\n  // console.log(`This is file content ==> ${fileContent}`);\n  return fileContent;\n};\n"]},"metadata":{},"sourceType":"script"}