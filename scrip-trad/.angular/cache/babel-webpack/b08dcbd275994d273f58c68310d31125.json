{"ast":null,"code":"import _asyncToGenerator from \"E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _awaitAsyncGenerator from \"E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\n\n/* global Blob, DOMException */\nimport { errors } from '../util.js';\nconst {\n  DISALLOWED\n} = errors;\n\nclass Sink {\n  /**\n   * @param {FileWriter} writer\n   * @param {FileEntry} fileEntry\n   */\n  constructor(writer, fileEntry) {\n    this.writer = writer;\n    this.fileEntry = fileEntry;\n  }\n  /**\n   * @param {BlobPart | Object} chunk\n   */\n\n\n  write(chunk) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof chunk === 'object') {\n        if (chunk.type === 'write') {\n          if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n            _this2.writer.seek(chunk.position);\n\n            if (_this2.writer.position !== chunk.position) {\n              yield new Promise((resolve, reject) => {\n                _this2.writer.onwriteend = resolve;\n                _this2.writer.onerror = reject;\n\n                _this2.writer.truncate(chunk.position);\n              });\n\n              _this2.writer.seek(chunk.position);\n            }\n          }\n\n          if (!('data' in chunk)) {\n            throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. write requires a data argument', 'SyntaxError');\n          }\n\n          chunk = chunk.data;\n        } else if (chunk.type === 'seek') {\n          if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n            _this2.writer.seek(chunk.position);\n\n            if (_this2.writer.position !== chunk.position) {\n              throw new DOMException('seeking position failed', 'InvalidStateError');\n            }\n\n            return;\n          } else {\n            throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. seek requires a position argument', 'SyntaxError');\n          }\n        } else if (chunk.type === 'truncate') {\n          return new Promise(resolve => {\n            if (Number.isInteger(chunk.size) && chunk.size >= 0) {\n              _this2.writer.onwriteend = evt => resolve();\n\n              _this2.writer.truncate(chunk.size);\n            } else {\n              throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. truncate requires a size argument', 'SyntaxError');\n            }\n          });\n        }\n      }\n\n      yield new Promise((resolve, reject) => {\n        _this2.writer.onwriteend = resolve;\n        _this2.writer.onerror = reject;\n\n        _this2.writer.write(new Blob([chunk]));\n      });\n    })();\n  }\n\n  close() {\n    return new Promise(this.fileEntry.file.bind(this.fileEntry));\n  }\n\n}\n\nexport class FileHandle {\n  /** @param {FileEntry} file */\n  constructor(file, writable = true) {\n    this.file = file;\n    this.kind = 'file';\n    this.writable = writable;\n    this.readable = true;\n  }\n\n  get name() {\n    return this.file.name;\n  }\n\n  isSameEntry(other) {\n    return this.file.toURL() === other.file.toURL();\n  }\n  /** @return {Promise<File>} */\n\n\n  getFile() {\n    return new Promise(this.file.file.bind(this.file));\n  }\n  /** @return {Promise<Sink>} */\n\n\n  createWritable(opts) {\n    if (!this.writable) throw new DOMException(...DISALLOWED);\n    return new Promise((resolve, reject) => this.file.createWriter(fileWriter => {\n      if (opts.keepExistingData === false) {\n        fileWriter.onwriteend = evt => resolve(new Sink(fileWriter, this.file));\n\n        fileWriter.truncate(0);\n      } else {\n        resolve(new Sink(fileWriter, this.file));\n      }\n    }, reject));\n  }\n\n}\nexport class FolderHandle {\n  /** @param {DirectoryEntry} dir */\n  constructor(dir, writable = true) {\n    this.dir = dir;\n    this.writable = writable;\n    this.readable = true;\n    this.kind = 'directory';\n    this.name = dir.name;\n  }\n  /** @param {FolderHandle} other */\n\n\n  isSameEntry(other) {\n    return this.dir.fullPath === other.dir.fullPath;\n  }\n  /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */\n\n\n  entries() {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const reader = _this.dir.createReader();\n\n      const entries = yield _awaitAsyncGenerator(new Promise(reader.readEntries.bind(reader)));\n\n      for (const x of entries) {\n        yield [x.name, x.isFile ? new FileHandle(x, _this.writable) : new FolderHandle(x, _this.writable)];\n      }\n    })();\n  }\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FolderHandle>}\n   */\n\n\n  getDirectoryHandle(name, opts) {\n    return new Promise((resolve, reject) => {\n      this.dir.getDirectory(name, opts, dir => {\n        resolve(new FolderHandle(dir));\n      }, reject);\n    });\n  }\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FileHandle>}\n   */\n\n\n  getFileHandle(name, opts) {\n    return new Promise((resolve, reject) => this.dir.getFile(name, opts, file => resolve(new FileHandle(file)), reject));\n  }\n  /**\n   * @param {string} name\n   * @param {{ recursive: boolean; }} opts\n   */\n\n\n  removeEntry(name, opts) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      /** @type {Error|FolderHandle|FileHandle} */\n      const entry = yield _this3.getDirectoryHandle(name, {\n        create: false\n      }).catch(err => err.name === 'TypeMismatchError' ? _this3.getFileHandle(name, {\n        create: false\n      }) : err);\n      if (entry instanceof Error) throw entry;\n      return new Promise((resolve, reject) => {\n        if (entry instanceof FolderHandle) {\n          opts.recursive ? entry.dir.removeRecursively(() => resolve(), reject) : entry.dir.remove(() => resolve(), reject);\n        } else if (entry.file) {\n          entry.file.remove(() => resolve(), reject);\n        }\n      });\n    })();\n  }\n\n}\nexport default ((opts = {}) => new Promise((resolve, reject) => window.webkitRequestFileSystem(opts._persistent, 0, e => resolve(new FolderHandle(e.root)), reject)));","map":{"version":3,"sources":["E:/DAW/2/ScripTrad/ScripTradCLI/scrip-trad/node_modules/native-file-system-adapter/src/adapters/sandbox.js"],"names":["errors","DISALLOWED","Sink","constructor","writer","fileEntry","write","chunk","type","Number","isInteger","position","seek","Promise","resolve","reject","onwriteend","onerror","truncate","DOMException","data","size","evt","Blob","close","file","bind","FileHandle","writable","kind","readable","name","isSameEntry","other","toURL","getFile","createWritable","opts","createWriter","fileWriter","keepExistingData","FolderHandle","dir","fullPath","entries","reader","createReader","readEntries","x","isFile","getDirectoryHandle","getDirectory","getFileHandle","removeEntry","entry","create","catch","err","Error","recursive","removeRecursively","remove","window","webkitRequestFileSystem","_persistent","e","root"],"mappings":"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","sourcesContent":["/* global Blob, DOMException */\n\nimport { errors } from '../util.js'\n\nconst { DISALLOWED } = errors\n\nclass Sink {\n  /**\n   * @param {FileWriter} writer\n   * @param {FileEntry} fileEntry\n   */\n  constructor (writer, fileEntry) {\n    this.writer = writer\n    this.fileEntry = fileEntry\n  }\n\n  /**\n   * @param {BlobPart | Object} chunk\n   */\n  async write (chunk) {\n    if (typeof chunk === 'object') {\n      if (chunk.type === 'write') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.writer.seek(chunk.position)\n          if (this.writer.position !== chunk.position) {\n            await new Promise((resolve, reject) => {\n              this.writer.onwriteend = resolve\n              this.writer.onerror = reject\n              this.writer.truncate(chunk.position)\n            })\n            this.writer.seek(chunk.position)\n          }\n        }\n        if (!('data' in chunk)) {\n          throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. write requires a data argument', 'SyntaxError')\n        }\n        chunk = chunk.data\n      } else if (chunk.type === 'seek') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.writer.seek(chunk.position)\n          if (this.writer.position !== chunk.position) {\n            throw new DOMException('seeking position failed', 'InvalidStateError')\n          }\n          return\n        } else {\n          throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. seek requires a position argument', 'SyntaxError')\n        }\n      } else if (chunk.type === 'truncate') {\n        return new Promise(resolve => {\n          if (Number.isInteger(chunk.size) && chunk.size >= 0) {\n            this.writer.onwriteend = evt => resolve()\n            this.writer.truncate(chunk.size)\n          } else {\n            throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. truncate requires a size argument', 'SyntaxError')\n          }\n        })\n      }\n    }\n    await new Promise((resolve, reject) => {\n      this.writer.onwriteend = resolve\n      this.writer.onerror = reject\n      this.writer.write(new Blob([chunk]))\n    })\n  }\n\n  close () {\n    return new Promise(this.fileEntry.file.bind(this.fileEntry))\n  }\n}\n\nexport class FileHandle {\n  /** @param {FileEntry} file */\n  constructor (file, writable = true) {\n    this.file = file\n    this.kind = 'file'\n    this.writable = writable\n    this.readable = true\n  }\n\n  get name () {\n    return this.file.name\n  }\n\n  isSameEntry (other) {\n    return this.file.toURL() === other.file.toURL()\n  }\n\n  /** @return {Promise<File>} */\n  getFile () {\n    return new Promise(this.file.file.bind(this.file))\n  }\n\n  /** @return {Promise<Sink>} */\n  createWritable (opts) {\n    if (!this.writable) throw new DOMException(...DISALLOWED)\n\n    return new Promise((resolve, reject) =>\n      this.file.createWriter(fileWriter => {\n        if (opts.keepExistingData === false) {\n          fileWriter.onwriteend = evt => resolve(new Sink(fileWriter, this.file))\n          fileWriter.truncate(0)\n        } else {\n          resolve(new Sink(fileWriter, this.file))\n        }\n      }, reject)\n    )\n  }\n}\n\nexport class FolderHandle {\n  /** @param {DirectoryEntry} dir */\n  constructor (dir, writable = true) {\n    this.dir = dir\n    this.writable = writable\n    this.readable = true\n    this.kind = 'directory'\n    this.name = dir.name\n  }\n\n  /** @param {FolderHandle} other */\n  isSameEntry (other) {\n    return this.dir.fullPath === other.dir.fullPath\n  }\n\n  /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */\n  async * entries () {\n    const reader = this.dir.createReader()\n    const entries = await new Promise(reader.readEntries.bind(reader))\n    for (const x of entries) {\n      yield [x.name, x.isFile ? new FileHandle(x, this.writable) : new FolderHandle(x, this.writable)]\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FolderHandle>}\n   */\n  getDirectoryHandle (name, opts) {\n    return new Promise((resolve, reject) => {\n      this.dir.getDirectory(name, opts, dir => {\n        resolve(new FolderHandle(dir))\n      }, reject)\n    })\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FileHandle>}\n   */\n  getFileHandle (name, opts) {\n    return new Promise((resolve, reject) =>\n      this.dir.getFile(name, opts, file => resolve(new FileHandle(file)), reject)\n    )\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ recursive: boolean; }} opts\n   */\n  async removeEntry (name, opts) {\n    /** @type {Error|FolderHandle|FileHandle} */\n    const entry = await this.getDirectoryHandle(name, { create: false }).catch(err =>\n      err.name === 'TypeMismatchError' ? this.getFileHandle(name, { create: false }) : err\n    )\n\n    if (entry instanceof Error) throw entry\n\n    return new Promise((resolve, reject) => {\n      if (entry instanceof FolderHandle) {\n        opts.recursive\n          ? entry.dir.removeRecursively(() => resolve(), reject)\n          : entry.dir.remove(() => resolve(), reject)\n      } else if (entry.file) {\n        entry.file.remove(() => resolve(), reject)\n      }\n    })\n  }\n}\n\nexport default (opts = {}) => new Promise((resolve, reject) =>\n  window.webkitRequestFileSystem(\n    opts._persistent, 0,\n    e => resolve(new FolderHandle(e.root)),\n    reject\n  )\n)\n"]},"metadata":{},"sourceType":"module"}